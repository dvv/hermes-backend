# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule DataProtocol do

  defmodule OrderDirection do

    @type t ::
      :asc #
    | :desc #

    defguard is_order_direction(value) when value === :asc or value === :desc

    @spec from_string!(String.t()) :: t()
    def from_string!("asc"), do: :asc
    def from_string!("desc"), do: :desc

    @spec to_string!(t()) :: String.t()
    def to_string!(:asc), do: "asc"
    def to_string!(:desc), do: "desc"

    @spec from_json!(String.t()) :: t()
    def from_json!("asc"), do: :asc
    def from_json!("desc"), do: :desc

    @spec to_json!(t()) :: String.t()
    def to_json!(:asc), do: "asc"
    def to_json!(:desc), do: "desc"

  end

  defmodule Collection do

    @enforce_keys [:items]
    defstruct [items: nil]

    @type t(tt) :: %Collection{items: [tt]}

    @spec from_json!(Igor.Json.json(), {Igor.Json.type()}) :: t(term)
    def from_json!(json, {tt_type}) do
      items = Igor.Json.parse_field!(json, "items", {:list, tt_type})
      %Collection{items: items}
    end

    @spec to_json!(t(term), {Igor.Json.type()}) :: Igor.Json.json()
    def to_json!(args, {tt_type}) do
      %{items: items} = args
      %{
        "items" => Igor.Json.pack_value(items, {:list, tt_type})
      }
    end

  end

  defmodule CollectionSlice do

    @enforce_keys [:total, :items]
    defstruct [total: nil, items: nil]

    @type t(tt) :: %CollectionSlice{total: integer, items: [tt]}

    @spec from_json!(Igor.Json.json(), {Igor.Json.type()}) :: t(term)
    def from_json!(json, {tt_type}) do
      total = Igor.Json.parse_field!(json, "total", :int)
      items = Igor.Json.parse_field!(json, "items", {:list, tt_type})
      %CollectionSlice{total: total, items: items}
    end

    @spec to_json!(t(term), {Igor.Json.type()}) :: Igor.Json.json()
    def to_json!(args, {tt_type}) do
      %{total: total, items: items} = args
      %{
        "total" => Igor.Json.pack_value(total, :int),
        "items" => Igor.Json.pack_value(items, {:list, tt_type})
      }
    end

  end

  defmodule TreeNode do

    defstruct [item: nil, children: []]

    @type t(tt) :: %TreeNode{item: tt | nil, children: [DataProtocol.TreeNode.t(tt)]}

    @spec from_json!(Igor.Json.json(), {Igor.Json.type()}) :: t(term)
    def from_json!(json, {tt_type}) do
      item = Igor.Json.parse_field!(json, "item", tt_type, nil)
      children = Igor.Json.parse_field!(json, "children", {:list, {:custom, DataProtocol.TreeNode, {tt_type}}}, [])
      %TreeNode{item: item, children: children}
    end

    @spec to_json!(t(term), {Igor.Json.type()}) :: Igor.Json.json()
    def to_json!(args, {tt_type}) do
      %{item: item, children: children} = args
      %{}
        |> Igor.Json.pack_field("item", item, tt_type)
        |> Igor.Json.pack_field("children", children, {:list, {:custom, DataProtocol.TreeNode, {tt_type}}})
    end

  end

  defmodule GenericResponse do

    @enforce_keys [:result]
    defstruct [result: nil]

    @type t :: %GenericResponse{result: boolean}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      result = Igor.Json.parse_field!(json, "result", :boolean)
      %GenericResponse{result: result}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{result: result} = args
      %{
        "result" => Igor.Json.pack_value(result, :boolean)
      }
    end

  end

  defmodule BadRequestError do

    defexception [error: nil]

    @type t(tt) :: %BadRequestError{error: tt}

    @spec message(t(term)) :: String.t()
    def message(_), do: "BadRequestError"

    @spec from_json!(Igor.Json.json(), {Igor.Json.type()}) :: t(term)
    def from_json!(json, {tt_type}) do
      error = Igor.Json.parse_field!(json, "error", tt_type)
      %BadRequestError{error: error}
    end

    @spec to_json!(t(term), {Igor.Json.type()}) :: Igor.Json.json()
    def to_json!(args, {tt_type}) do
      %{error: error} = args
      %{
        "error" => Igor.Json.pack_value(error, tt_type)
      }
    end

  end

  defmodule ForbiddenError do

    defexception []

    @type t :: %ForbiddenError{}

    @spec message(t()) :: String.t()
    def message(_), do: "ForbiddenError"

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(%{}), do: %ForbiddenError{}

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(%ForbiddenError{}), do: %{}

  end

  defmodule NotFoundError do

    defexception []

    @type t :: %NotFoundError{}

    @spec message(t()) :: String.t()
    def message(_), do: "NotFoundError"

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(%{}), do: %NotFoundError{}

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(%NotFoundError{}), do: %{}

  end

  defmodule InternalServerError do

    defexception [error: nil]

    @type t :: %InternalServerError{error: String.t()}

    @spec message(t()) :: String.t()
    def message(_), do: "InternalServerError"

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      error = Igor.Json.parse_field!(json, "error", :string)
      %InternalServerError{error: error}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{error: error} = args
      %{
        "error" => Igor.Json.pack_value(error, :string)
      }
    end

  end

end
