# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule DbProtocol do

  defmodule AccessRole do

    @type t ::
      :maintainer # Maintainer
    | :admin # Administrator

    defguard is_access_role(value) when value === :maintainer or value === :admin

    @spec from_string!(String.t()) :: t()
    def from_string!("maintainer"), do: :maintainer
    def from_string!("admin"), do: :admin

    @spec to_string!(t()) :: String.t()
    def to_string!(:maintainer), do: "maintainer"
    def to_string!(:admin), do: "admin"

    @spec from_json!(String.t()) :: t()
    def from_json!("maintainer"), do: :maintainer
    def from_json!("admin"), do: :admin

    @spec to_json!(t()) :: String.t()
    def to_json!(:maintainer), do: "maintainer"
    def to_json!(:admin), do: "admin"

  end

  defmodule AccessRoleObject do

    defstruct [role: nil]

    @type t :: %AccessRoleObject{role: DbProtocol.AccessRole.t() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      role = Igor.Json.parse_field!(json, "role", {:custom, DbProtocol.AccessRole}, nil)
      %AccessRoleObject{role: role}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{role: role} = args
      %{}
        |> Igor.Json.pack_field("role", role, {:custom, DbProtocol.AccessRole})
    end

  end

  defmodule PersonnelAccount do

    @enforce_keys [:id, :rev, :username, :is_blocked, :is_deleted, :is_superadmin, :is_office_manager, :linked_to_projects, :highlights, :created_at, :updated_at]
    defstruct [id: nil, rev: nil, username: nil, name: nil, email: nil, phone: nil, office_id: nil, office_name: nil, office_country_alpha2: nil, office_country_name: nil, department: nil, job_title: nil, is_blocked: nil, is_deleted: nil, is_superadmin: nil, is_office_manager: nil, supervisor_id: nil, location: nil, supervisor_username: nil, supervisor_name: nil, allocated_to_project_id: nil, allocated_to_project_name: nil, linked_to_projects: nil, role_id: nil, role_code: nil, role_title: nil, highlights: nil, hired_at: nil, fired_at: nil, created_at: nil, updated_at: nil]

    @type t :: %PersonnelAccount{id: integer, rev: integer, username: String.t(), name: String.t() | nil, email: String.t() | nil, phone: String.t() | nil, office_id: integer | nil, office_name: String.t() | nil, office_country_alpha2: String.t() | nil, office_country_name: String.t() | nil, department: String.t() | nil, job_title: String.t() | nil, is_blocked: boolean, is_deleted: boolean, is_superadmin: boolean, is_office_manager: boolean, supervisor_id: integer | nil, location: String.t() | nil, supervisor_username: String.t() | nil, supervisor_name: String.t() | nil, allocated_to_project_id: integer | nil, allocated_to_project_name: String.t() | nil, linked_to_projects: Igor.Json.json(), role_id: integer | nil, role_code: String.t() | nil, role_title: String.t() | nil, highlights: Igor.Json.json(), hired_at: CommonProtocol.date_time() | nil, fired_at: CommonProtocol.date_time() | nil, created_at: CommonProtocol.date_time(), updated_at: CommonProtocol.date_time()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      id = Igor.Json.parse_field!(json, "id", :long)
      rev = Igor.Json.parse_field!(json, "rev", :int)
      username = Igor.Json.parse_field!(json, "username", :string)
      name = Igor.Json.parse_field!(json, "name", :string, nil)
      email = Igor.Json.parse_field!(json, "email", :string, nil)
      phone = Igor.Json.parse_field!(json, "phone", :string, nil)
      office_id = Igor.Json.parse_field!(json, "office_id", :long, nil)
      office_name = Igor.Json.parse_field!(json, "office_name", :string, nil)
      office_country_alpha2 = Igor.Json.parse_field!(json, "office_country_alpha2", :string, nil)
      office_country_name = Igor.Json.parse_field!(json, "office_country_name", :string, nil)
      department = Igor.Json.parse_field!(json, "department", :string, nil)
      job_title = Igor.Json.parse_field!(json, "job_title", :string, nil)
      is_blocked = Igor.Json.parse_field!(json, "is_blocked", :boolean)
      is_deleted = Igor.Json.parse_field!(json, "is_deleted", :boolean)
      is_superadmin = Igor.Json.parse_field!(json, "is_superadmin", :boolean)
      is_office_manager = Igor.Json.parse_field!(json, "is_office_manager", :boolean)
      supervisor_id = Igor.Json.parse_field!(json, "supervisor_id", :long, nil)
      location = Igor.Json.parse_field!(json, "location", :string, nil)
      supervisor_username = Igor.Json.parse_field!(json, "supervisor_username", :string, nil)
      supervisor_name = Igor.Json.parse_field!(json, "supervisor_name", :string, nil)
      allocated_to_project_id = Igor.Json.parse_field!(json, "allocated_to_project_id", :long, nil)
      allocated_to_project_name = Igor.Json.parse_field!(json, "allocated_to_project_name", :string, nil)
      linked_to_projects = Igor.Json.parse_field!(json, "linked_to_projects", :json)
      role_id = Igor.Json.parse_field!(json, "role_id", :long, nil)
      role_code = Igor.Json.parse_field!(json, "role_code", :string, nil)
      role_title = Igor.Json.parse_field!(json, "role_title", :string, nil)
      highlights = Igor.Json.parse_field!(json, "highlights", :json)
      hired_at = Igor.Json.parse_field!(json, "hired_at", {:custom, Util.DateTime}, nil)
      fired_at = Igor.Json.parse_field!(json, "fired_at", {:custom, Util.DateTime}, nil)
      created_at = Igor.Json.parse_field!(json, "created_at", {:custom, Util.DateTime})
      updated_at = Igor.Json.parse_field!(json, "updated_at", {:custom, Util.DateTime})
      %PersonnelAccount{
        id: id,
        rev: rev,
        username: username,
        name: name,
        email: email,
        phone: phone,
        office_id: office_id,
        office_name: office_name,
        office_country_alpha2: office_country_alpha2,
        office_country_name: office_country_name,
        department: department,
        job_title: job_title,
        is_blocked: is_blocked,
        is_deleted: is_deleted,
        is_superadmin: is_superadmin,
        is_office_manager: is_office_manager,
        supervisor_id: supervisor_id,
        location: location,
        supervisor_username: supervisor_username,
        supervisor_name: supervisor_name,
        allocated_to_project_id: allocated_to_project_id,
        allocated_to_project_name: allocated_to_project_name,
        linked_to_projects: linked_to_projects,
        role_id: role_id,
        role_code: role_code,
        role_title: role_title,
        highlights: highlights,
        hired_at: hired_at,
        fired_at: fired_at,
        created_at: created_at,
        updated_at: updated_at
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        id: id,
        rev: rev,
        username: username,
        name: name,
        email: email,
        phone: phone,
        office_id: office_id,
        office_name: office_name,
        office_country_alpha2: office_country_alpha2,
        office_country_name: office_country_name,
        department: department,
        job_title: job_title,
        is_blocked: is_blocked,
        is_deleted: is_deleted,
        is_superadmin: is_superadmin,
        is_office_manager: is_office_manager,
        supervisor_id: supervisor_id,
        location: location,
        supervisor_username: supervisor_username,
        supervisor_name: supervisor_name,
        allocated_to_project_id: allocated_to_project_id,
        allocated_to_project_name: allocated_to_project_name,
        linked_to_projects: linked_to_projects,
        role_id: role_id,
        role_code: role_code,
        role_title: role_title,
        highlights: highlights,
        hired_at: hired_at,
        fired_at: fired_at,
        created_at: created_at,
        updated_at: updated_at
      } = args
      %{}
        |> Igor.Json.pack_field("id", id, :long)
        |> Igor.Json.pack_field("rev", rev, :int)
        |> Igor.Json.pack_field("username", username, :string)
        |> Igor.Json.pack_field("name", name, :string)
        |> Igor.Json.pack_field("email", email, :string)
        |> Igor.Json.pack_field("phone", phone, :string)
        |> Igor.Json.pack_field("office_id", office_id, :long)
        |> Igor.Json.pack_field("office_name", office_name, :string)
        |> Igor.Json.pack_field("office_country_alpha2", office_country_alpha2, :string)
        |> Igor.Json.pack_field("office_country_name", office_country_name, :string)
        |> Igor.Json.pack_field("department", department, :string)
        |> Igor.Json.pack_field("job_title", job_title, :string)
        |> Igor.Json.pack_field("is_blocked", is_blocked, :boolean)
        |> Igor.Json.pack_field("is_deleted", is_deleted, :boolean)
        |> Igor.Json.pack_field("is_superadmin", is_superadmin, :boolean)
        |> Igor.Json.pack_field("is_office_manager", is_office_manager, :boolean)
        |> Igor.Json.pack_field("supervisor_id", supervisor_id, :long)
        |> Igor.Json.pack_field("location", location, :string)
        |> Igor.Json.pack_field("supervisor_username", supervisor_username, :string)
        |> Igor.Json.pack_field("supervisor_name", supervisor_name, :string)
        |> Igor.Json.pack_field("allocated_to_project_id", allocated_to_project_id, :long)
        |> Igor.Json.pack_field("allocated_to_project_name", allocated_to_project_name, :string)
        |> Igor.Json.pack_field("linked_to_projects", linked_to_projects, :json)
        |> Igor.Json.pack_field("role_id", role_id, :long)
        |> Igor.Json.pack_field("role_code", role_code, :string)
        |> Igor.Json.pack_field("role_title", role_title, :string)
        |> Igor.Json.pack_field("highlights", highlights, :json)
        |> Igor.Json.pack_field("hired_at", hired_at, {:custom, Util.DateTime})
        |> Igor.Json.pack_field("fired_at", fired_at, {:custom, Util.DateTime})
        |> Igor.Json.pack_field("created_at", created_at, {:custom, Util.DateTime})
        |> Igor.Json.pack_field("updated_at", updated_at, {:custom, Util.DateTime})
    end

  end

  defmodule PersonnelAccountRole do

    @enforce_keys [:personnel_id, :username, :project_id, :project_name]
    defstruct [personnel_id: nil, username: nil, project_id: nil, project_name: nil, group_roles: nil, user_role: nil]

    @type t :: %PersonnelAccountRole{personnel_id: integer, username: String.t(), project_id: integer, project_name: String.t(), group_roles: %{String.t() => DbProtocol.AccessRoleObject.t()} | nil, user_role: DbProtocol.AccessRole.t() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      personnel_id = Igor.Json.parse_field!(json, "personnel_id", :long)
      username = Igor.Json.parse_field!(json, "username", :string)
      project_id = Igor.Json.parse_field!(json, "project_id", :long)
      project_name = Igor.Json.parse_field!(json, "project_name", :string)
      group_roles = Igor.Json.parse_field!(json, "group_roles", {:map, :string, {:custom, DbProtocol.AccessRoleObject}}, nil)
      user_role = Igor.Json.parse_field!(json, "user_role", {:custom, DbProtocol.AccessRole}, nil)
      %PersonnelAccountRole{
        personnel_id: personnel_id,
        username: username,
        project_id: project_id,
        project_name: project_name,
        group_roles: group_roles,
        user_role: user_role
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        personnel_id: personnel_id,
        username: username,
        project_id: project_id,
        project_name: project_name,
        group_roles: group_roles,
        user_role: user_role
      } = args
      %{}
        |> Igor.Json.pack_field("personnel_id", personnel_id, :long)
        |> Igor.Json.pack_field("username", username, :string)
        |> Igor.Json.pack_field("project_id", project_id, :long)
        |> Igor.Json.pack_field("project_name", project_name, :string)
        |> Igor.Json.pack_field("group_roles", group_roles, {:map, :string, {:custom, DbProtocol.AccessRoleObject}})
        |> Igor.Json.pack_field("user_role", user_role, {:custom, DbProtocol.AccessRole})
    end

  end

  defmodule PersonnelGroup do

    @enforce_keys [:id, :rev, :name, :is_deleted, :members, :member_count, :is_superadmin, :created_at, :updated_at]
    defstruct [id: nil, rev: nil, name: nil, description: nil, is_deleted: nil, members: nil, member_count: nil, is_superadmin: nil, created_at: nil, updated_at: nil]

    @type t :: %PersonnelGroup{id: integer, rev: integer, name: String.t(), description: String.t() | nil, is_deleted: boolean, members: [String.t()], member_count: integer, is_superadmin: boolean, created_at: CommonProtocol.date_time(), updated_at: CommonProtocol.date_time()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      id = Igor.Json.parse_field!(json, "id", :long)
      rev = Igor.Json.parse_field!(json, "rev", :int)
      name = Igor.Json.parse_field!(json, "name", :string)
      description = Igor.Json.parse_field!(json, "description", :string, nil)
      is_deleted = Igor.Json.parse_field!(json, "is_deleted", :boolean)
      members = Igor.Json.parse_field!(json, "members", {:list, :string})
      member_count = Igor.Json.parse_field!(json, "member_count", :int)
      is_superadmin = Igor.Json.parse_field!(json, "is_superadmin", :boolean)
      created_at = Igor.Json.parse_field!(json, "created_at", {:custom, Util.DateTime})
      updated_at = Igor.Json.parse_field!(json, "updated_at", {:custom, Util.DateTime})
      %PersonnelGroup{
        id: id,
        rev: rev,
        name: name,
        description: description,
        is_deleted: is_deleted,
        members: members,
        member_count: member_count,
        is_superadmin: is_superadmin,
        created_at: created_at,
        updated_at: updated_at
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        id: id,
        rev: rev,
        name: name,
        description: description,
        is_deleted: is_deleted,
        members: members,
        member_count: member_count,
        is_superadmin: is_superadmin,
        created_at: created_at,
        updated_at: updated_at
      } = args
      %{}
        |> Igor.Json.pack_field("id", id, :long)
        |> Igor.Json.pack_field("rev", rev, :int)
        |> Igor.Json.pack_field("name", name, :string)
        |> Igor.Json.pack_field("description", description, :string)
        |> Igor.Json.pack_field("is_deleted", is_deleted, :boolean)
        |> Igor.Json.pack_field("members", members, {:list, :string})
        |> Igor.Json.pack_field("member_count", member_count, :int)
        |> Igor.Json.pack_field("is_superadmin", is_superadmin, :boolean)
        |> Igor.Json.pack_field("created_at", created_at, {:custom, Util.DateTime})
        |> Igor.Json.pack_field("updated_at", updated_at, {:custom, Util.DateTime})
    end

  end

  defmodule PersonnelGroupRole do

    @enforce_keys [:group_id, :group_name, :project_id, :project_name]
    defstruct [group_id: nil, group_name: nil, project_id: nil, project_name: nil, group_role: nil]

    @type t :: %PersonnelGroupRole{group_id: integer, group_name: String.t(), project_id: integer, project_name: String.t(), group_role: DbProtocol.AccessRole.t() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      group_id = Igor.Json.parse_field!(json, "group_id", :long)
      group_name = Igor.Json.parse_field!(json, "group_name", :string)
      project_id = Igor.Json.parse_field!(json, "project_id", :long)
      project_name = Igor.Json.parse_field!(json, "project_name", :string)
      group_role = Igor.Json.parse_field!(json, "group_role", {:custom, DbProtocol.AccessRole}, nil)
      %PersonnelGroupRole{
        group_id: group_id,
        group_name: group_name,
        project_id: project_id,
        project_name: project_name,
        group_role: group_role
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        group_id: group_id,
        group_name: group_name,
        project_id: project_id,
        project_name: project_name,
        group_role: group_role
      } = args
      %{}
        |> Igor.Json.pack_field("group_id", group_id, :long)
        |> Igor.Json.pack_field("group_name", group_name, :string)
        |> Igor.Json.pack_field("project_id", project_id, :long)
        |> Igor.Json.pack_field("project_name", project_name, :string)
        |> Igor.Json.pack_field("group_role", group_role, {:custom, DbProtocol.AccessRole})
    end

  end

  defmodule PersonnelSession do

    @enforce_keys [:id, :personnel_id, :username, :created_at, :valid_thru]
    defstruct [id: nil, personnel_id: nil, username: nil, created_at: nil, valid_thru: nil]

    @type t :: %PersonnelSession{id: String.t(), personnel_id: integer, username: String.t(), created_at: CommonProtocol.date_time(), valid_thru: CommonProtocol.date_time()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      id = Igor.Json.parse_field!(json, "id", :string)
      personnel_id = Igor.Json.parse_field!(json, "personnel_id", :long)
      username = Igor.Json.parse_field!(json, "username", :string)
      created_at = Igor.Json.parse_field!(json, "created_at", {:custom, Util.DateTime})
      valid_thru = Igor.Json.parse_field!(json, "valid_thru", {:custom, Util.DateTime})
      %PersonnelSession{
        id: id,
        personnel_id: personnel_id,
        username: username,
        created_at: created_at,
        valid_thru: valid_thru
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        id: id,
        personnel_id: personnel_id,
        username: username,
        created_at: created_at,
        valid_thru: valid_thru
      } = args
      %{
        "id" => Igor.Json.pack_value(id, :string),
        "personnel_id" => Igor.Json.pack_value(personnel_id, :long),
        "username" => Igor.Json.pack_value(username, :string),
        "created_at" => Util.DateTime.to_json!(created_at),
        "valid_thru" => Util.DateTime.to_json!(valid_thru)
      }
    end

  end

  defmodule Country do

    @enforce_keys [:id, :name, :alpha2, :alpha3, :created_at]
    defstruct [id: nil, name: nil, alpha2: nil, alpha3: nil, created_at: nil]

    @type t :: %Country{id: integer, name: String.t(), alpha2: String.t(), alpha3: String.t(), created_at: CommonProtocol.date_time()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      id = Igor.Json.parse_field!(json, "id", :int)
      name = Igor.Json.parse_field!(json, "name", :string)
      alpha2 = Igor.Json.parse_field!(json, "alpha2", :string)
      alpha3 = Igor.Json.parse_field!(json, "alpha3", :string)
      created_at = Igor.Json.parse_field!(json, "created_at", {:custom, Util.DateTime})
      %Country{
        id: id,
        name: name,
        alpha2: alpha2,
        alpha3: alpha3,
        created_at: created_at
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        id: id,
        name: name,
        alpha2: alpha2,
        alpha3: alpha3,
        created_at: created_at
      } = args
      %{
        "id" => Igor.Json.pack_value(id, :int),
        "name" => Igor.Json.pack_value(name, :string),
        "alpha2" => Igor.Json.pack_value(alpha2, :string),
        "alpha3" => Igor.Json.pack_value(alpha3, :string),
        "created_at" => Util.DateTime.to_json!(created_at)
      }
    end

  end

  defmodule Office do

    @enforce_keys [:id, :rev, :name, :country_id, :country_alpha2, :country_name, :allowed_roles, :created_at, :updated_at]
    defstruct [id: nil, rev: nil, name: nil, country_id: nil, country_alpha2: nil, country_name: nil, city: nil, address: nil, postal_code: nil, group_id: nil, group_name: nil, allowed_roles: nil, visma_country: nil, visma_company_id: nil, created_at: nil, updated_at: nil]

    @type t :: %Office{id: integer, rev: integer, name: String.t(), country_id: integer, country_alpha2: String.t(), country_name: String.t(), city: String.t() | nil, address: String.t() | nil, postal_code: String.t() | nil, group_id: integer | nil, group_name: String.t() | nil, allowed_roles: [integer], visma_country: String.t() | nil, visma_company_id: String.t() | nil, created_at: CommonProtocol.date_time(), updated_at: CommonProtocol.date_time()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      id = Igor.Json.parse_field!(json, "id", :long)
      rev = Igor.Json.parse_field!(json, "rev", :int)
      name = Igor.Json.parse_field!(json, "name", :string)
      country_id = Igor.Json.parse_field!(json, "country_id", :int)
      country_alpha2 = Igor.Json.parse_field!(json, "country_alpha2", :string)
      country_name = Igor.Json.parse_field!(json, "country_name", :string)
      city = Igor.Json.parse_field!(json, "city", :string, nil)
      address = Igor.Json.parse_field!(json, "address", :string, nil)
      postal_code = Igor.Json.parse_field!(json, "postal_code", :string, nil)
      group_id = Igor.Json.parse_field!(json, "group_id", :long, nil)
      group_name = Igor.Json.parse_field!(json, "group_name", :string, nil)
      allowed_roles = Igor.Json.parse_field!(json, "allowed_roles", {:list, :long})
      visma_country = Igor.Json.parse_field!(json, "visma_country", :string, nil)
      visma_company_id = Igor.Json.parse_field!(json, "visma_company_id", :string, nil)
      created_at = Igor.Json.parse_field!(json, "created_at", {:custom, Util.DateTime})
      updated_at = Igor.Json.parse_field!(json, "updated_at", {:custom, Util.DateTime})
      %Office{
        id: id,
        rev: rev,
        name: name,
        country_id: country_id,
        country_alpha2: country_alpha2,
        country_name: country_name,
        city: city,
        address: address,
        postal_code: postal_code,
        group_id: group_id,
        group_name: group_name,
        allowed_roles: allowed_roles,
        visma_country: visma_country,
        visma_company_id: visma_company_id,
        created_at: created_at,
        updated_at: updated_at
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        id: id,
        rev: rev,
        name: name,
        country_id: country_id,
        country_alpha2: country_alpha2,
        country_name: country_name,
        city: city,
        address: address,
        postal_code: postal_code,
        group_id: group_id,
        group_name: group_name,
        allowed_roles: allowed_roles,
        visma_country: visma_country,
        visma_company_id: visma_company_id,
        created_at: created_at,
        updated_at: updated_at
      } = args
      %{}
        |> Igor.Json.pack_field("id", id, :long)
        |> Igor.Json.pack_field("rev", rev, :int)
        |> Igor.Json.pack_field("name", name, :string)
        |> Igor.Json.pack_field("country_id", country_id, :int)
        |> Igor.Json.pack_field("country_alpha2", country_alpha2, :string)
        |> Igor.Json.pack_field("country_name", country_name, :string)
        |> Igor.Json.pack_field("city", city, :string)
        |> Igor.Json.pack_field("address", address, :string)
        |> Igor.Json.pack_field("postal_code", postal_code, :string)
        |> Igor.Json.pack_field("group_id", group_id, :long)
        |> Igor.Json.pack_field("group_name", group_name, :string)
        |> Igor.Json.pack_field("allowed_roles", allowed_roles, {:list, :long})
        |> Igor.Json.pack_field("visma_country", visma_country, :string)
        |> Igor.Json.pack_field("visma_company_id", visma_company_id, :string)
        |> Igor.Json.pack_field("created_at", created_at, {:custom, Util.DateTime})
        |> Igor.Json.pack_field("updated_at", updated_at, {:custom, Util.DateTime})
    end

  end

  defmodule Project do

    @enforce_keys [:id, :rev, :title, :key, :leading_office_id, :leading_office_name, :finance_code, :invoiceable, :task_code, :created_at, :updated_at]
    defstruct [id: nil, rev: nil, title: nil, key: nil, color: nil, supervisor_id: nil, supervisor_username: nil, supervisor_name: nil, leading_office_id: nil, leading_office_name: nil, finance_code: nil, invoiceable: nil, is_archived: false, task_code: nil, started_at: nil, finished_at: nil, created_at: nil, updated_at: nil]

    @type t :: %Project{id: integer, rev: integer, title: String.t(), key: String.t(), color: String.t() | nil, supervisor_id: integer | nil, supervisor_username: String.t() | nil, supervisor_name: String.t() | nil, leading_office_id: integer, leading_office_name: String.t(), finance_code: String.t(), invoiceable: boolean, is_archived: boolean, task_code: DbProtocol.TaskKind.t(), started_at: CommonProtocol.date_time() | nil, finished_at: CommonProtocol.date_time() | nil, created_at: CommonProtocol.date_time(), updated_at: CommonProtocol.date_time()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      id = Igor.Json.parse_field!(json, "id", :long)
      rev = Igor.Json.parse_field!(json, "rev", :int)
      title = Igor.Json.parse_field!(json, "title", :string)
      key = Igor.Json.parse_field!(json, "key", :string)
      color = Igor.Json.parse_field!(json, "color", :string, nil)
      supervisor_id = Igor.Json.parse_field!(json, "supervisor_id", :long, nil)
      supervisor_username = Igor.Json.parse_field!(json, "supervisor_username", :string, nil)
      supervisor_name = Igor.Json.parse_field!(json, "supervisor_name", :string, nil)
      leading_office_id = Igor.Json.parse_field!(json, "leading_office_id", :long)
      leading_office_name = Igor.Json.parse_field!(json, "leading_office_name", :string)
      finance_code = Igor.Json.parse_field!(json, "finance_code", :string)
      invoiceable = Igor.Json.parse_field!(json, "invoiceable", :boolean)
      is_archived = Igor.Json.parse_field!(json, "is_archived", :boolean, false)
      task_code = Igor.Json.parse_field!(json, "task_code", {:custom, DbProtocol.TaskKind})
      started_at = Igor.Json.parse_field!(json, "started_at", {:custom, Util.DateTime}, nil)
      finished_at = Igor.Json.parse_field!(json, "finished_at", {:custom, Util.DateTime}, nil)
      created_at = Igor.Json.parse_field!(json, "created_at", {:custom, Util.DateTime})
      updated_at = Igor.Json.parse_field!(json, "updated_at", {:custom, Util.DateTime})
      %Project{
        id: id,
        rev: rev,
        title: title,
        key: key,
        color: color,
        supervisor_id: supervisor_id,
        supervisor_username: supervisor_username,
        supervisor_name: supervisor_name,
        leading_office_id: leading_office_id,
        leading_office_name: leading_office_name,
        finance_code: finance_code,
        invoiceable: invoiceable,
        is_archived: is_archived,
        task_code: task_code,
        started_at: started_at,
        finished_at: finished_at,
        created_at: created_at,
        updated_at: updated_at
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        id: id,
        rev: rev,
        title: title,
        key: key,
        color: color,
        supervisor_id: supervisor_id,
        supervisor_username: supervisor_username,
        supervisor_name: supervisor_name,
        leading_office_id: leading_office_id,
        leading_office_name: leading_office_name,
        finance_code: finance_code,
        invoiceable: invoiceable,
        is_archived: is_archived,
        task_code: task_code,
        started_at: started_at,
        finished_at: finished_at,
        created_at: created_at,
        updated_at: updated_at
      } = args
      %{}
        |> Igor.Json.pack_field("id", id, :long)
        |> Igor.Json.pack_field("rev", rev, :int)
        |> Igor.Json.pack_field("title", title, :string)
        |> Igor.Json.pack_field("key", key, :string)
        |> Igor.Json.pack_field("color", color, :string)
        |> Igor.Json.pack_field("supervisor_id", supervisor_id, :long)
        |> Igor.Json.pack_field("supervisor_username", supervisor_username, :string)
        |> Igor.Json.pack_field("supervisor_name", supervisor_name, :string)
        |> Igor.Json.pack_field("leading_office_id", leading_office_id, :long)
        |> Igor.Json.pack_field("leading_office_name", leading_office_name, :string)
        |> Igor.Json.pack_field("finance_code", finance_code, :string)
        |> Igor.Json.pack_field("invoiceable", invoiceable, :boolean)
        |> Igor.Json.pack_field("is_archived", is_archived, :boolean)
        |> Igor.Json.pack_field("task_code", task_code, {:custom, DbProtocol.TaskKind})
        |> Igor.Json.pack_field("started_at", started_at, {:custom, Util.DateTime})
        |> Igor.Json.pack_field("finished_at", finished_at, {:custom, Util.DateTime})
        |> Igor.Json.pack_field("created_at", created_at, {:custom, Util.DateTime})
        |> Igor.Json.pack_field("updated_at", updated_at, {:custom, Util.DateTime})
    end

  end

  defmodule TimeOffKind do

    @type t ::
      :vacation # Vacation
    | :paid_vacation # Vacation Paid
    | :unpaid_vacation # Vacation Unpaid
    | :absence # Absence
    | :travel # Travel
    | :vab # Care of Child
    | :sick # Sick Paid
    | :unpaid_sick # Sick Unpaid
    | :holiday # Bank Day / Holiday
    | :empty # Empty
    | :parental_leave # Leave Parental
    | :maternity_leave # Leave Maternity
    | :time_off # Time Off
    | :temp_leave # Leave Temporary

    defguard is_time_off_kind(value) when value === :vacation or value === :paid_vacation or value === :unpaid_vacation or value === :absence or value === :travel or value === :vab or value === :sick or value === :unpaid_sick or value === :holiday or value === :empty or value === :parental_leave or value === :maternity_leave or value === :time_off or value === :temp_leave

    @spec from_string!(String.t()) :: t()
    def from_string!("vacation"), do: :vacation
    def from_string!("paid_vacation"), do: :paid_vacation
    def from_string!("unpaid_vacation"), do: :unpaid_vacation
    def from_string!("absence"), do: :absence
    def from_string!("travel"), do: :travel
    def from_string!("vab"), do: :vab
    def from_string!("sick"), do: :sick
    def from_string!("unpaid_sick"), do: :unpaid_sick
    def from_string!("holiday"), do: :holiday
    def from_string!("empty"), do: :empty
    def from_string!("parental_leave"), do: :parental_leave
    def from_string!("maternity_leave"), do: :maternity_leave
    def from_string!("time_off"), do: :time_off
    def from_string!("temp_leave"), do: :temp_leave

    @spec to_string!(t()) :: String.t()
    def to_string!(:vacation), do: "vacation"
    def to_string!(:paid_vacation), do: "paid_vacation"
    def to_string!(:unpaid_vacation), do: "unpaid_vacation"
    def to_string!(:absence), do: "absence"
    def to_string!(:travel), do: "travel"
    def to_string!(:vab), do: "vab"
    def to_string!(:sick), do: "sick"
    def to_string!(:unpaid_sick), do: "unpaid_sick"
    def to_string!(:holiday), do: "holiday"
    def to_string!(:empty), do: "empty"
    def to_string!(:parental_leave), do: "parental_leave"
    def to_string!(:maternity_leave), do: "maternity_leave"
    def to_string!(:time_off), do: "time_off"
    def to_string!(:temp_leave), do: "temp_leave"

    @spec from_json!(String.t()) :: t()
    def from_json!("vacation"), do: :vacation
    def from_json!("paid_vacation"), do: :paid_vacation
    def from_json!("unpaid_vacation"), do: :unpaid_vacation
    def from_json!("absence"), do: :absence
    def from_json!("travel"), do: :travel
    def from_json!("vab"), do: :vab
    def from_json!("sick"), do: :sick
    def from_json!("unpaid_sick"), do: :unpaid_sick
    def from_json!("holiday"), do: :holiday
    def from_json!("empty"), do: :empty
    def from_json!("parental_leave"), do: :parental_leave
    def from_json!("maternity_leave"), do: :maternity_leave
    def from_json!("time_off"), do: :time_off
    def from_json!("temp_leave"), do: :temp_leave

    @spec to_json!(t()) :: String.t()
    def to_json!(:vacation), do: "vacation"
    def to_json!(:paid_vacation), do: "paid_vacation"
    def to_json!(:unpaid_vacation), do: "unpaid_vacation"
    def to_json!(:absence), do: "absence"
    def to_json!(:travel), do: "travel"
    def to_json!(:vab), do: "vab"
    def to_json!(:sick), do: "sick"
    def to_json!(:unpaid_sick), do: "unpaid_sick"
    def to_json!(:holiday), do: "holiday"
    def to_json!(:empty), do: "empty"
    def to_json!(:parental_leave), do: "parental_leave"
    def to_json!(:maternity_leave), do: "maternity_leave"
    def to_json!(:time_off), do: "time_off"
    def to_json!(:temp_leave), do: "temp_leave"

  end

  defmodule TaskKind do

    @type t ::
      :project # Project
    | :cont_dev # Continue Development
    | :rnd # Research & Development

    defguard is_task_kind(value) when value === :project or value === :cont_dev or value === :rnd

    @spec from_string!(String.t()) :: t()
    def from_string!("project"), do: :project
    def from_string!("cont_dev"), do: :cont_dev
    def from_string!("rnd"), do: :rnd

    @spec to_string!(t()) :: String.t()
    def to_string!(:project), do: "project"
    def to_string!(:cont_dev), do: "cont_dev"
    def to_string!(:rnd), do: "rnd"

    @spec from_json!(String.t()) :: t()
    def from_json!("project"), do: :project
    def from_json!("cont_dev"), do: :cont_dev
    def from_json!("rnd"), do: :rnd

    @spec to_json!(t()) :: String.t()
    def to_json!(:project), do: "project"
    def to_json!(:cont_dev), do: "cont_dev"
    def to_json!(:rnd), do: "rnd"

  end

  defmodule TimesheetCell do

    @enforce_keys [:id, :personnel_id, :personnel_username, :personnel_name, :is_protected, :cell_date_iso, :cell_date, :created_at, :updated_at]
    defstruct [id: nil, personnel_id: nil, personnel_username: nil, personnel_name: nil, is_protected: nil, project_id: nil, project_name: nil, time_off: nil, cell_date_iso: nil, cell_date: nil, comment: nil, created_at: nil, updated_at: nil]

    @type t :: %TimesheetCell{id: integer, personnel_id: integer, personnel_username: String.t(), personnel_name: String.t(), is_protected: boolean, project_id: integer | nil, project_name: String.t() | nil, time_off: DbProtocol.TimeOffKind.t() | nil, cell_date_iso: String.t(), cell_date: CommonProtocol.date_time(), comment: String.t() | nil, created_at: CommonProtocol.date_time(), updated_at: CommonProtocol.date_time()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      id = Igor.Json.parse_field!(json, "id", :long)
      personnel_id = Igor.Json.parse_field!(json, "personnel_id", :long)
      personnel_username = Igor.Json.parse_field!(json, "personnel_username", :string)
      personnel_name = Igor.Json.parse_field!(json, "personnel_name", :string)
      is_protected = Igor.Json.parse_field!(json, "is_protected", :boolean)
      project_id = Igor.Json.parse_field!(json, "project_id", :long, nil)
      project_name = Igor.Json.parse_field!(json, "project_name", :string, nil)
      time_off = Igor.Json.parse_field!(json, "time_off", {:custom, DbProtocol.TimeOffKind}, nil)
      cell_date_iso = Igor.Json.parse_field!(json, "cell_date_iso", :string)
      cell_date = Igor.Json.parse_field!(json, "cell_date", {:custom, Util.DateTime})
      comment = Igor.Json.parse_field!(json, "comment", :string, nil)
      created_at = Igor.Json.parse_field!(json, "created_at", {:custom, Util.DateTime})
      updated_at = Igor.Json.parse_field!(json, "updated_at", {:custom, Util.DateTime})
      %TimesheetCell{
        id: id,
        personnel_id: personnel_id,
        personnel_username: personnel_username,
        personnel_name: personnel_name,
        is_protected: is_protected,
        project_id: project_id,
        project_name: project_name,
        time_off: time_off,
        cell_date_iso: cell_date_iso,
        cell_date: cell_date,
        comment: comment,
        created_at: created_at,
        updated_at: updated_at
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        id: id,
        personnel_id: personnel_id,
        personnel_username: personnel_username,
        personnel_name: personnel_name,
        is_protected: is_protected,
        project_id: project_id,
        project_name: project_name,
        time_off: time_off,
        cell_date_iso: cell_date_iso,
        cell_date: cell_date,
        comment: comment,
        created_at: created_at,
        updated_at: updated_at
      } = args
      %{}
        |> Igor.Json.pack_field("id", id, :long)
        |> Igor.Json.pack_field("personnel_id", personnel_id, :long)
        |> Igor.Json.pack_field("personnel_username", personnel_username, :string)
        |> Igor.Json.pack_field("personnel_name", personnel_name, :string)
        |> Igor.Json.pack_field("is_protected", is_protected, :boolean)
        |> Igor.Json.pack_field("project_id", project_id, :long)
        |> Igor.Json.pack_field("project_name", project_name, :string)
        |> Igor.Json.pack_field("time_off", time_off, {:custom, DbProtocol.TimeOffKind})
        |> Igor.Json.pack_field("cell_date_iso", cell_date_iso, :string)
        |> Igor.Json.pack_field("cell_date", cell_date, {:custom, Util.DateTime})
        |> Igor.Json.pack_field("comment", comment, :string)
        |> Igor.Json.pack_field("created_at", created_at, {:custom, Util.DateTime})
        |> Igor.Json.pack_field("updated_at", updated_at, {:custom, Util.DateTime})
    end

  end

  defmodule Role do

    @enforce_keys [:id, :rev, :code, :title, :created_at, :updated_at]
    defstruct [id: nil, rev: nil, code: nil, title: nil, created_at: nil, updated_at: nil]

    @type t :: %Role{id: integer, rev: integer, code: String.t(), title: String.t(), created_at: CommonProtocol.date_time(), updated_at: CommonProtocol.date_time()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      id = Igor.Json.parse_field!(json, "id", :long)
      rev = Igor.Json.parse_field!(json, "rev", :int)
      code = Igor.Json.parse_field!(json, "code", :string)
      title = Igor.Json.parse_field!(json, "title", :string)
      created_at = Igor.Json.parse_field!(json, "created_at", {:custom, Util.DateTime})
      updated_at = Igor.Json.parse_field!(json, "updated_at", {:custom, Util.DateTime})
      %Role{
        id: id,
        rev: rev,
        code: code,
        title: title,
        created_at: created_at,
        updated_at: updated_at
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        id: id,
        rev: rev,
        code: code,
        title: title,
        created_at: created_at,
        updated_at: updated_at
      } = args
      %{
        "id" => Igor.Json.pack_value(id, :long),
        "rev" => Igor.Json.pack_value(rev, :int),
        "code" => Igor.Json.pack_value(code, :string),
        "title" => Igor.Json.pack_value(title, :string),
        "created_at" => Util.DateTime.to_json!(created_at),
        "updated_at" => Util.DateTime.to_json!(updated_at)
      }
    end

  end

  defmodule Team do

    @enforce_keys [:id, :rev, :title, :members, :created_at, :updated_at]
    defstruct [id: nil, rev: nil, title: nil, members: nil, created_by: nil, created_by_username: nil, created_by_name: nil, created_at: nil, updated_at: nil]

    @type t :: %Team{id: integer, rev: integer, title: String.t(), members: [String.t()], created_by: integer | nil, created_by_username: String.t() | nil, created_by_name: String.t() | nil, created_at: CommonProtocol.date_time(), updated_at: CommonProtocol.date_time()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      id = Igor.Json.parse_field!(json, "id", :long)
      rev = Igor.Json.parse_field!(json, "rev", :int)
      title = Igor.Json.parse_field!(json, "title", :string)
      members = Igor.Json.parse_field!(json, "members", {:list, :string})
      created_by = Igor.Json.parse_field!(json, "created_by", :long, nil)
      created_by_username = Igor.Json.parse_field!(json, "created_by_username", :string, nil)
      created_by_name = Igor.Json.parse_field!(json, "created_by_name", :string, nil)
      created_at = Igor.Json.parse_field!(json, "created_at", {:custom, Util.DateTime})
      updated_at = Igor.Json.parse_field!(json, "updated_at", {:custom, Util.DateTime})
      %Team{
        id: id,
        rev: rev,
        title: title,
        members: members,
        created_by: created_by,
        created_by_username: created_by_username,
        created_by_name: created_by_name,
        created_at: created_at,
        updated_at: updated_at
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        id: id,
        rev: rev,
        title: title,
        members: members,
        created_by: created_by,
        created_by_username: created_by_username,
        created_by_name: created_by_name,
        created_at: created_at,
        updated_at: updated_at
      } = args
      %{}
        |> Igor.Json.pack_field("id", id, :long)
        |> Igor.Json.pack_field("rev", rev, :int)
        |> Igor.Json.pack_field("title", title, :string)
        |> Igor.Json.pack_field("members", members, {:list, :string})
        |> Igor.Json.pack_field("created_by", created_by, :long)
        |> Igor.Json.pack_field("created_by_username", created_by_username, :string)
        |> Igor.Json.pack_field("created_by_name", created_by_name, :string)
        |> Igor.Json.pack_field("created_at", created_at, {:custom, Util.DateTime})
        |> Igor.Json.pack_field("updated_at", updated_at, {:custom, Util.DateTime})
    end

  end

  defmodule HistoryActor do

    @type t ::
      :user #
    | :robot #
    | :anonymous #

    defguard is_history_actor(value) when value === :user or value === :robot or value === :anonymous

    @spec from_string!(String.t()) :: t()
    def from_string!("user"), do: :user
    def from_string!("robot"), do: :robot
    def from_string!("anonymous"), do: :anonymous

    @spec to_string!(t()) :: String.t()
    def to_string!(:user), do: "user"
    def to_string!(:robot), do: "robot"
    def to_string!(:anonymous), do: "anonymous"

    @spec from_json!(String.t()) :: t()
    def from_json!("user"), do: :user
    def from_json!("robot"), do: :robot
    def from_json!("anonymous"), do: :anonymous

    @spec to_json!(t()) :: String.t()
    def to_json!(:user), do: "user"
    def to_json!(:robot), do: "robot"
    def to_json!(:anonymous), do: "anonymous"

  end

  defmodule HistoryEntity do

    @type t ::
      :auth #
    | :session #
    | :settings #
    | :user #
    | :group #
    | :group_membership #
    | :country #
    | :role #
    | :office #
    | :project #
    | :team #
    | :team_membership #
    | :timecell #

    defguard is_history_entity(value) when value === :auth or value === :session or value === :settings or value === :user or value === :group or value === :group_membership or value === :country or value === :role or value === :office or value === :project or value === :team or value === :team_membership or value === :timecell

    @spec from_string!(String.t()) :: t()
    def from_string!("auth"), do: :auth
    def from_string!("session"), do: :session
    def from_string!("settings"), do: :settings
    def from_string!("user"), do: :user
    def from_string!("group"), do: :group
    def from_string!("group_membership"), do: :group_membership
    def from_string!("country"), do: :country
    def from_string!("role"), do: :role
    def from_string!("office"), do: :office
    def from_string!("project"), do: :project
    def from_string!("team"), do: :team
    def from_string!("team_membership"), do: :team_membership
    def from_string!("timecell"), do: :timecell

    @spec to_string!(t()) :: String.t()
    def to_string!(:auth), do: "auth"
    def to_string!(:session), do: "session"
    def to_string!(:settings), do: "settings"
    def to_string!(:user), do: "user"
    def to_string!(:group), do: "group"
    def to_string!(:group_membership), do: "group_membership"
    def to_string!(:country), do: "country"
    def to_string!(:role), do: "role"
    def to_string!(:office), do: "office"
    def to_string!(:project), do: "project"
    def to_string!(:team), do: "team"
    def to_string!(:team_membership), do: "team_membership"
    def to_string!(:timecell), do: "timecell"

    @spec from_json!(String.t()) :: t()
    def from_json!("auth"), do: :auth
    def from_json!("session"), do: :session
    def from_json!("settings"), do: :settings
    def from_json!("user"), do: :user
    def from_json!("group"), do: :group
    def from_json!("group_membership"), do: :group_membership
    def from_json!("country"), do: :country
    def from_json!("role"), do: :role
    def from_json!("office"), do: :office
    def from_json!("project"), do: :project
    def from_json!("team"), do: :team
    def from_json!("team_membership"), do: :team_membership
    def from_json!("timecell"), do: :timecell

    @spec to_json!(t()) :: String.t()
    def to_json!(:auth), do: "auth"
    def to_json!(:session), do: "session"
    def to_json!(:settings), do: "settings"
    def to_json!(:user), do: "user"
    def to_json!(:group), do: "group"
    def to_json!(:group_membership), do: "group_membership"
    def to_json!(:country), do: "country"
    def to_json!(:role), do: "role"
    def to_json!(:office), do: "office"
    def to_json!(:project), do: "project"
    def to_json!(:team), do: "team"
    def to_json!(:team_membership), do: "team_membership"
    def to_json!(:timecell), do: "timecell"

  end

  defmodule HistoryOperation do

    @type t ::
      :create #
    | :read #
    | :update #
    | :delete #
    | :undelete #
    | :block #
    | :unblock #
    | :login #
    | :logout #
    | :allocate #
    | :deallocate #
    | :protect #
    | :unprotect #
    | :absence #

    defguard is_history_operation(value) when value === :create or value === :read or value === :update or value === :delete or value === :undelete or value === :block or value === :unblock or value === :login or value === :logout or value === :allocate or value === :deallocate or value === :protect or value === :unprotect or value === :absence

    @spec from_string!(String.t()) :: t()
    def from_string!("create"), do: :create
    def from_string!("read"), do: :read
    def from_string!("update"), do: :update
    def from_string!("delete"), do: :delete
    def from_string!("undelete"), do: :undelete
    def from_string!("block"), do: :block
    def from_string!("unblock"), do: :unblock
    def from_string!("login"), do: :login
    def from_string!("logout"), do: :logout
    def from_string!("allocate"), do: :allocate
    def from_string!("deallocate"), do: :deallocate
    def from_string!("protect"), do: :protect
    def from_string!("unprotect"), do: :unprotect
    def from_string!("absence"), do: :absence

    @spec to_string!(t()) :: String.t()
    def to_string!(:create), do: "create"
    def to_string!(:read), do: "read"
    def to_string!(:update), do: "update"
    def to_string!(:delete), do: "delete"
    def to_string!(:undelete), do: "undelete"
    def to_string!(:block), do: "block"
    def to_string!(:unblock), do: "unblock"
    def to_string!(:login), do: "login"
    def to_string!(:logout), do: "logout"
    def to_string!(:allocate), do: "allocate"
    def to_string!(:deallocate), do: "deallocate"
    def to_string!(:protect), do: "protect"
    def to_string!(:unprotect), do: "unprotect"
    def to_string!(:absence), do: "absence"

    @spec from_json!(String.t()) :: t()
    def from_json!("create"), do: :create
    def from_json!("read"), do: :read
    def from_json!("update"), do: :update
    def from_json!("delete"), do: :delete
    def from_json!("undelete"), do: :undelete
    def from_json!("block"), do: :block
    def from_json!("unblock"), do: :unblock
    def from_json!("login"), do: :login
    def from_json!("logout"), do: :logout
    def from_json!("allocate"), do: :allocate
    def from_json!("deallocate"), do: :deallocate
    def from_json!("protect"), do: :protect
    def from_json!("unprotect"), do: :unprotect
    def from_json!("absence"), do: :absence

    @spec to_json!(t()) :: String.t()
    def to_json!(:create), do: "create"
    def to_json!(:read), do: "read"
    def to_json!(:update), do: "update"
    def to_json!(:delete), do: "delete"
    def to_json!(:undelete), do: "undelete"
    def to_json!(:block), do: "block"
    def to_json!(:unblock), do: "unblock"
    def to_json!(:login), do: "login"
    def to_json!(:logout), do: "logout"
    def to_json!(:allocate), do: "allocate"
    def to_json!(:deallocate), do: "deallocate"
    def to_json!(:protect), do: "protect"
    def to_json!(:unprotect), do: "unprotect"
    def to_json!(:absence), do: "absence"

  end

  defmodule HistoryEntry do

    @enforce_keys [:id, :actor, :entity, :operation, :is_bulk, :properties, :result, :created_at]
    defstruct [id: nil, actor: nil, actor_id: nil, actor_name: nil, actor_username: nil, entity: nil, entity_id: nil, entity_param: nil, operation: nil, is_bulk: nil, properties: nil, result: nil, comment: nil, created_at: nil]

    @type t :: %HistoryEntry{id: integer, actor: DbProtocol.HistoryActor.t(), actor_id: integer | nil, actor_name: String.t() | nil, actor_username: String.t() | nil, entity: DbProtocol.HistoryEntity.t(), entity_id: integer | nil, entity_param: String.t() | nil, operation: DbProtocol.HistoryOperation.t(), is_bulk: boolean, properties: Igor.Json.json(), result: boolean, comment: String.t() | nil, created_at: CommonProtocol.date_time()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      id = Igor.Json.parse_field!(json, "id", :long)
      actor = Igor.Json.parse_field!(json, "actor", {:custom, DbProtocol.HistoryActor})
      actor_id = Igor.Json.parse_field!(json, "actor_id", :long, nil)
      actor_name = Igor.Json.parse_field!(json, "actor_name", :string, nil)
      actor_username = Igor.Json.parse_field!(json, "actor_username", :string, nil)
      entity = Igor.Json.parse_field!(json, "entity", {:custom, DbProtocol.HistoryEntity})
      entity_id = Igor.Json.parse_field!(json, "entity_id", :long, nil)
      entity_param = Igor.Json.parse_field!(json, "entity_param", :string, nil)
      operation = Igor.Json.parse_field!(json, "operation", {:custom, DbProtocol.HistoryOperation})
      is_bulk = Igor.Json.parse_field!(json, "is_bulk", :boolean)
      properties = Igor.Json.parse_field!(json, "properties", :json)
      result = Igor.Json.parse_field!(json, "result", :boolean)
      comment = Igor.Json.parse_field!(json, "comment", :string, nil)
      created_at = Igor.Json.parse_field!(json, "created_at", {:custom, Util.DateTime})
      %HistoryEntry{
        id: id,
        actor: actor,
        actor_id: actor_id,
        actor_name: actor_name,
        actor_username: actor_username,
        entity: entity,
        entity_id: entity_id,
        entity_param: entity_param,
        operation: operation,
        is_bulk: is_bulk,
        properties: properties,
        result: result,
        comment: comment,
        created_at: created_at
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        id: id,
        actor: actor,
        actor_id: actor_id,
        actor_name: actor_name,
        actor_username: actor_username,
        entity: entity,
        entity_id: entity_id,
        entity_param: entity_param,
        operation: operation,
        is_bulk: is_bulk,
        properties: properties,
        result: result,
        comment: comment,
        created_at: created_at
      } = args
      %{}
        |> Igor.Json.pack_field("id", id, :long)
        |> Igor.Json.pack_field("actor", actor, {:custom, DbProtocol.HistoryActor})
        |> Igor.Json.pack_field("actor_id", actor_id, :long)
        |> Igor.Json.pack_field("actor_name", actor_name, :string)
        |> Igor.Json.pack_field("actor_username", actor_username, :string)
        |> Igor.Json.pack_field("entity", entity, {:custom, DbProtocol.HistoryEntity})
        |> Igor.Json.pack_field("entity_id", entity_id, :long)
        |> Igor.Json.pack_field("entity_param", entity_param, :string)
        |> Igor.Json.pack_field("operation", operation, {:custom, DbProtocol.HistoryOperation})
        |> Igor.Json.pack_field("is_bulk", is_bulk, :boolean)
        |> Igor.Json.pack_field("properties", properties, :json)
        |> Igor.Json.pack_field("result", result, :boolean)
        |> Igor.Json.pack_field("comment", comment, :string)
        |> Igor.Json.pack_field("created_at", created_at, {:custom, Util.DateTime})
    end

  end

  defmodule ReportStatus do

    @type t ::
      :created #
    | :running #
    | :stopped #
    | :completed #
    | :error #
    | :scheduled #

    defguard is_report_status(value) when value === :created or value === :running or value === :stopped or value === :completed or value === :error or value === :scheduled

    @spec from_string!(String.t()) :: t()
    def from_string!("created"), do: :created
    def from_string!("running"), do: :running
    def from_string!("stopped"), do: :stopped
    def from_string!("completed"), do: :completed
    def from_string!("error"), do: :error
    def from_string!("scheduled"), do: :scheduled

    @spec to_string!(t()) :: String.t()
    def to_string!(:created), do: "created"
    def to_string!(:running), do: "running"
    def to_string!(:stopped), do: "stopped"
    def to_string!(:completed), do: "completed"
    def to_string!(:error), do: "error"
    def to_string!(:scheduled), do: "scheduled"

    @spec from_json!(String.t()) :: t()
    def from_json!("created"), do: :created
    def from_json!("running"), do: :running
    def from_json!("stopped"), do: :stopped
    def from_json!("completed"), do: :completed
    def from_json!("error"), do: :error
    def from_json!("scheduled"), do: :scheduled

    @spec to_json!(t()) :: String.t()
    def to_json!(:created), do: "created"
    def to_json!(:running), do: "running"
    def to_json!(:stopped), do: "stopped"
    def to_json!(:completed), do: "completed"
    def to_json!(:error), do: "error"
    def to_json!(:scheduled), do: "scheduled"

  end

  defmodule VismaReport do

    @enforce_keys [:id, :office_id, :office_name, :year, :month, :comment, :created_by, :created_by_username, :created_by_name, :created_at, :updated_at]
    defstruct [id: nil, office_id: nil, office_name: nil, year: nil, month: nil, comment: nil, omit_ids: [], omit_uids: [], created_by: nil, created_by_username: nil, created_by_name: nil, updated_by: nil, updated_by_username: nil, updated_by_name: nil, delivery_task_id: nil, delivery_data: nil, delivery_status: nil, delivered_at: nil, created_at: nil, updated_at: nil]

    @type t :: %VismaReport{id: integer, office_id: integer, office_name: String.t(), year: integer, month: integer, comment: String.t(), omit_ids: [integer] | nil, omit_uids: [String.t()] | nil, created_by: integer, created_by_username: String.t(), created_by_name: String.t(), updated_by: integer | nil, updated_by_username: String.t() | nil, updated_by_name: String.t() | nil, delivery_task_id: String.t() | nil, delivery_data: Igor.Json.json() | nil, delivery_status: DbProtocol.ReportStatus.t() | nil, delivered_at: CommonProtocol.date_time() | nil, created_at: CommonProtocol.date_time(), updated_at: CommonProtocol.date_time()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      id = Igor.Json.parse_field!(json, "id", :long)
      office_id = Igor.Json.parse_field!(json, "office_id", :long)
      office_name = Igor.Json.parse_field!(json, "office_name", :string)
      year = Igor.Json.parse_field!(json, "year", :int)
      month = Igor.Json.parse_field!(json, "month", :int)
      comment = Igor.Json.parse_field!(json, "comment", :string)
      omit_ids = Igor.Json.parse_field!(json, "omit_ids", {:list, :long}, [])
      omit_uids = Igor.Json.parse_field!(json, "omit_uids", {:list, :string}, [])
      created_by = Igor.Json.parse_field!(json, "created_by", :long)
      created_by_username = Igor.Json.parse_field!(json, "created_by_username", :string)
      created_by_name = Igor.Json.parse_field!(json, "created_by_name", :string)
      updated_by = Igor.Json.parse_field!(json, "updated_by", :long, nil)
      updated_by_username = Igor.Json.parse_field!(json, "updated_by_username", :string, nil)
      updated_by_name = Igor.Json.parse_field!(json, "updated_by_name", :string, nil)
      delivery_task_id = Igor.Json.parse_field!(json, "delivery_task_id", :string, nil)
      delivery_data = Igor.Json.parse_field!(json, "delivery_data", :json, nil)
      delivery_status = Igor.Json.parse_field!(json, "delivery_status", {:custom, DbProtocol.ReportStatus}, nil)
      delivered_at = Igor.Json.parse_field!(json, "delivered_at", {:custom, Util.DateTime}, nil)
      created_at = Igor.Json.parse_field!(json, "created_at", {:custom, Util.DateTime})
      updated_at = Igor.Json.parse_field!(json, "updated_at", {:custom, Util.DateTime})
      %VismaReport{
        id: id,
        office_id: office_id,
        office_name: office_name,
        year: year,
        month: month,
        comment: comment,
        omit_ids: omit_ids,
        omit_uids: omit_uids,
        created_by: created_by,
        created_by_username: created_by_username,
        created_by_name: created_by_name,
        updated_by: updated_by,
        updated_by_username: updated_by_username,
        updated_by_name: updated_by_name,
        delivery_task_id: delivery_task_id,
        delivery_data: delivery_data,
        delivery_status: delivery_status,
        delivered_at: delivered_at,
        created_at: created_at,
        updated_at: updated_at
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        id: id,
        office_id: office_id,
        office_name: office_name,
        year: year,
        month: month,
        comment: comment,
        omit_ids: omit_ids,
        omit_uids: omit_uids,
        created_by: created_by,
        created_by_username: created_by_username,
        created_by_name: created_by_name,
        updated_by: updated_by,
        updated_by_username: updated_by_username,
        updated_by_name: updated_by_name,
        delivery_task_id: delivery_task_id,
        delivery_data: delivery_data,
        delivery_status: delivery_status,
        delivered_at: delivered_at,
        created_at: created_at,
        updated_at: updated_at
      } = args
      %{}
        |> Igor.Json.pack_field("id", id, :long)
        |> Igor.Json.pack_field("office_id", office_id, :long)
        |> Igor.Json.pack_field("office_name", office_name, :string)
        |> Igor.Json.pack_field("year", year, :int)
        |> Igor.Json.pack_field("month", month, :int)
        |> Igor.Json.pack_field("comment", comment, :string)
        |> Igor.Json.pack_field("omit_ids", omit_ids, {:list, :long})
        |> Igor.Json.pack_field("omit_uids", omit_uids, {:list, :string})
        |> Igor.Json.pack_field("created_by", created_by, :long)
        |> Igor.Json.pack_field("created_by_username", created_by_username, :string)
        |> Igor.Json.pack_field("created_by_name", created_by_name, :string)
        |> Igor.Json.pack_field("updated_by", updated_by, :long)
        |> Igor.Json.pack_field("updated_by_username", updated_by_username, :string)
        |> Igor.Json.pack_field("updated_by_name", updated_by_name, :string)
        |> Igor.Json.pack_field("delivery_task_id", delivery_task_id, :string)
        |> Igor.Json.pack_field("delivery_data", delivery_data, :json)
        |> Igor.Json.pack_field("delivery_status", delivery_status, {:custom, DbProtocol.ReportStatus})
        |> Igor.Json.pack_field("delivered_at", delivered_at, {:custom, Util.DateTime})
        |> Igor.Json.pack_field("created_at", created_at, {:custom, Util.DateTime})
        |> Igor.Json.pack_field("updated_at", updated_at, {:custom, Util.DateTime})
    end

  end

  defmodule Highlight do

    @enforce_keys [:id, :rev, :code, :title, :created_at, :updated_at]
    defstruct [id: nil, rev: nil, code: nil, title: nil, created_at: nil, updated_at: nil]

    @type t :: %Highlight{id: integer, rev: integer, code: String.t(), title: String.t(), created_at: CommonProtocol.date_time(), updated_at: CommonProtocol.date_time()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      id = Igor.Json.parse_field!(json, "id", :long)
      rev = Igor.Json.parse_field!(json, "rev", :int)
      code = Igor.Json.parse_field!(json, "code", :string)
      title = Igor.Json.parse_field!(json, "title", :string)
      created_at = Igor.Json.parse_field!(json, "created_at", {:custom, Util.DateTime})
      updated_at = Igor.Json.parse_field!(json, "updated_at", {:custom, Util.DateTime})
      %Highlight{
        id: id,
        rev: rev,
        code: code,
        title: title,
        created_at: created_at,
        updated_at: updated_at
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        id: id,
        rev: rev,
        code: code,
        title: title,
        created_at: created_at,
        updated_at: updated_at
      } = args
      %{
        "id" => Igor.Json.pack_value(id, :long),
        "rev" => Igor.Json.pack_value(rev, :int),
        "code" => Igor.Json.pack_value(code, :string),
        "title" => Igor.Json.pack_value(title, :string),
        "created_at" => Util.DateTime.to_json!(created_at),
        "updated_at" => Util.DateTime.to_json!(updated_at)
      }
    end

  end

end
