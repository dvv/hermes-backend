# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule WebProtocol.HermesAdminService do

  defmodule PersonnelAccount do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        id = Igor.Json.parse_field!(conn.path_params, "id", :long)
        {conn, id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, id} ->
          handle_get(conn, id)
      end
    end
    defp handle_method("PUT", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request_content = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, WebProtocol.UpdatePersonnelAccountRequest})
        id = Igor.Json.parse_field!(conn.path_params, "id", :long)
        {conn, request_content, id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request_content, id} ->
          handle_put(conn, request_content, id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET, PUT")
        |> send_resp(405, "")
    end

    defp handle_get(conn, id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account", args: [id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAdminService.Impl.get_personnel_account(id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DbProtocol.PersonnelAccount})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

    defp handle_put(conn, request_content, id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAdminService.Impl.update_personnel_account", args: [request_content, id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAdminService.Impl.update_personnel_account(request_content, id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAdminService.Impl.update_personnel_account", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DbProtocol.PersonnelAccount})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.BadRequestError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.update_personnel_account", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.BadRequestError, {{:custom, WebProtocol.UpdatePersonnelAccountError}}})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(400, body)
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.update_personnel_account", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.update_personnel_account", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.update_personnel_account", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule GetPersonnelAccountByUsername do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        username = Igor.Json.parse_field!(conn.path_params, "username", :string)
        {conn, username}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, username} ->
          handle_get(conn, username)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, username) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account_by_username", args: [username, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAdminService.Impl.get_personnel_account_by_username(username, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account_by_username", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DbProtocol.PersonnelAccount})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account_by_username", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account_by_username", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account_by_username", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule GetPersonnelAccounts do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        conn = fetch_query_params(conn)
        needle = Igor.Json.parse_field!(conn.query_params, "needle", {:option, :string})
        order_by = Igor.Json.parse_field!(conn.query_params, "order_by", {:custom, WebProtocol.PersonnelAccountOrderBy})
        order_dir = Igor.Json.parse_field!(conn.query_params, "order_dir", {:custom, DataProtocol.OrderDirection})
        offset = Igor.Json.parse_field!(conn.query_params, "offset", :int)
        limit = Igor.Json.parse_field!(conn.query_params, "limit", :int)
        {conn, needle, order_by, order_dir, offset, limit}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, needle, order_by, order_dir, offset, limit} ->
          handle_get(conn, needle, order_by, order_dir, offset, limit)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, needle, order_by, order_dir, offset, limit) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_accounts", args: [needle, order_by, order_dir, offset, limit, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAdminService.Impl.get_personnel_accounts(needle, order_by, order_dir, offset, limit, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_accounts", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.CollectionSlice, {{:custom, DbProtocol.PersonnelAccount}}})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_accounts", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_accounts", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule GetPersonnelAccountRoles do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        conn = fetch_query_params(conn)
        id = Igor.Json.parse_field!(conn.path_params, "id", :long)
        needle = Igor.Json.parse_field!(conn.query_params, "needle", {:option, :string})
        order_by = Igor.Json.parse_field!(conn.query_params, "order_by", {:custom, WebProtocol.PersonnelAccountRoleOrderBy})
        order_dir = Igor.Json.parse_field!(conn.query_params, "order_dir", {:custom, DataProtocol.OrderDirection})
        offset = Igor.Json.parse_field!(conn.query_params, "offset", :int)
        limit = Igor.Json.parse_field!(conn.query_params, "limit", :int)
        {conn, id, needle, order_by, order_dir, offset, limit}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, id, needle, order_by, order_dir, offset, limit} ->
          handle_get(conn, id, needle, order_by, order_dir, offset, limit)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, id, needle, order_by, order_dir, offset, limit) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account_roles", args: [id, needle, order_by, order_dir, offset, limit, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAdminService.Impl.get_personnel_account_roles(id, needle, order_by, order_dir, offset, limit, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account_roles", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.CollectionSlice, {{:custom, DbProtocol.PersonnelAccountRole}}})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account_roles", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account_roles", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule GetPersonnelAccountRolesForProject do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        conn = fetch_query_params(conn)
        project_id = Igor.Json.parse_field!(conn.path_params, "project_id", :long)
        needle = Igor.Json.parse_field!(conn.query_params, "needle", {:option, :string})
        order_by = Igor.Json.parse_field!(conn.query_params, "order_by", {:custom, WebProtocol.PersonnelAccountRoleOrderBy})
        order_dir = Igor.Json.parse_field!(conn.query_params, "order_dir", {:custom, DataProtocol.OrderDirection})
        offset = Igor.Json.parse_field!(conn.query_params, "offset", :int)
        limit = Igor.Json.parse_field!(conn.query_params, "limit", :int)
        {conn, project_id, needle, order_by, order_dir, offset, limit}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, project_id, needle, order_by, order_dir, offset, limit} ->
          handle_get(conn, project_id, needle, order_by, order_dir, offset, limit)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, project_id, needle, order_by, order_dir, offset, limit) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account_roles_for_project", args: [project_id, needle, order_by, order_dir, offset, limit, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAdminService.Impl.get_personnel_account_roles_for_project(project_id, needle, order_by, order_dir, offset, limit, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account_roles_for_project", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.CollectionSlice, {{:custom, DbProtocol.PersonnelAccountRole}}})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account_roles_for_project", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account_roles_for_project", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule AdminPersonnelAccountRole do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        id = Igor.Json.parse_field!(conn.path_params, "id", :long)
        project_id = Igor.Json.parse_field!(conn.path_params, "project_id", :long)
        {conn, id, project_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, id, project_id} ->
          handle_get(conn, id, project_id)
      end
    end
    defp handle_method("PUT", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, WebProtocol.AccessRoleUpdateRequest})
        id = Igor.Json.parse_field!(conn.path_params, "id", :long)
        project_id = Igor.Json.parse_field!(conn.path_params, "project_id", :long)
        {conn, request, id, project_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request, id, project_id} ->
          handle_put(conn, request, id, project_id)
      end
    end
    defp handle_method("DELETE", conn) do
      try do
        id = Igor.Json.parse_field!(conn.path_params, "id", :long)
        project_id = Igor.Json.parse_field!(conn.path_params, "project_id", :long)
        {conn, id, project_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, id, project_id} ->
          handle_delete(conn, id, project_id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET, PUT, DELETE")
        |> send_resp(405, "")
    end

    defp handle_get(conn, id, project_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account_role", args: [id, project_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAdminService.Impl.get_personnel_account_role(id, project_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account_role", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DbProtocol.PersonnelAccountRole})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account_role", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account_role", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_account_role", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

    defp handle_put(conn, request, id, project_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAdminService.Impl.set_personnel_account_role", args: [request, id, project_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAdminService.Impl.set_personnel_account_role(request, id, project_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAdminService.Impl.set_personnel_account_role", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.GenericResponse})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.set_personnel_account_role", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.set_personnel_account_role", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.set_personnel_account_role", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

    defp handle_delete(conn, id, project_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAdminService.Impl.reset_personnel_account_role", args: [id, project_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAdminService.Impl.reset_personnel_account_role(id, project_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAdminService.Impl.reset_personnel_account_role", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.GenericResponse})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.reset_personnel_account_role", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.reset_personnel_account_role", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.reset_personnel_account_role", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule GetPersonnelGroup do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        id = Igor.Json.parse_field!(conn.path_params, "id", :long)
        {conn, id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, id} ->
          handle_get(conn, id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group", args: [id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAdminService.Impl.get_personnel_group(id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DbProtocol.PersonnelGroup})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule GetPersonnelGroupByName do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        name = Igor.Json.parse_field!(conn.path_params, "name", :string)
        {conn, name}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, name} ->
          handle_get(conn, name)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, name) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group_by_name", args: [name, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAdminService.Impl.get_personnel_group_by_name(name, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group_by_name", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DbProtocol.PersonnelGroup})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group_by_name", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group_by_name", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group_by_name", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule GetPersonnelGroups do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        conn = fetch_query_params(conn)
        needle = Igor.Json.parse_field!(conn.query_params, "needle", {:option, :string})
        order_by = Igor.Json.parse_field!(conn.query_params, "order_by", {:custom, WebProtocol.PersonnelGroupOrderBy})
        order_dir = Igor.Json.parse_field!(conn.query_params, "order_dir", {:custom, DataProtocol.OrderDirection})
        offset = Igor.Json.parse_field!(conn.query_params, "offset", :int)
        limit = Igor.Json.parse_field!(conn.query_params, "limit", :int)
        {conn, needle, order_by, order_dir, offset, limit}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, needle, order_by, order_dir, offset, limit} ->
          handle_get(conn, needle, order_by, order_dir, offset, limit)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, needle, order_by, order_dir, offset, limit) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_groups", args: [needle, order_by, order_dir, offset, limit, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAdminService.Impl.get_personnel_groups(needle, order_by, order_dir, offset, limit, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_groups", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.CollectionSlice, {{:custom, DbProtocol.PersonnelGroup}}})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_groups", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_groups", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule GetPersonnelGroupRoles do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        conn = fetch_query_params(conn)
        id = Igor.Json.parse_field!(conn.path_params, "id", :long)
        needle = Igor.Json.parse_field!(conn.query_params, "needle", {:option, :string})
        order_by = Igor.Json.parse_field!(conn.query_params, "order_by", {:custom, WebProtocol.PersonnelGroupRoleOrderBy})
        order_dir = Igor.Json.parse_field!(conn.query_params, "order_dir", {:custom, DataProtocol.OrderDirection})
        offset = Igor.Json.parse_field!(conn.query_params, "offset", :int)
        limit = Igor.Json.parse_field!(conn.query_params, "limit", :int)
        {conn, id, needle, order_by, order_dir, offset, limit}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, id, needle, order_by, order_dir, offset, limit} ->
          handle_get(conn, id, needle, order_by, order_dir, offset, limit)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, id, needle, order_by, order_dir, offset, limit) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group_roles", args: [id, needle, order_by, order_dir, offset, limit, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAdminService.Impl.get_personnel_group_roles(id, needle, order_by, order_dir, offset, limit, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group_roles", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.CollectionSlice, {{:custom, DbProtocol.PersonnelGroupRole}}})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group_roles", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group_roles", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule GetPersonnelGroupRolesForProject do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        conn = fetch_query_params(conn)
        project_id = Igor.Json.parse_field!(conn.path_params, "project_id", :long)
        needle = Igor.Json.parse_field!(conn.query_params, "needle", {:option, :string})
        order_by = Igor.Json.parse_field!(conn.query_params, "order_by", {:custom, WebProtocol.PersonnelGroupRoleOrderBy})
        order_dir = Igor.Json.parse_field!(conn.query_params, "order_dir", {:custom, DataProtocol.OrderDirection})
        offset = Igor.Json.parse_field!(conn.query_params, "offset", :int)
        limit = Igor.Json.parse_field!(conn.query_params, "limit", :int)
        {conn, project_id, needle, order_by, order_dir, offset, limit}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, project_id, needle, order_by, order_dir, offset, limit} ->
          handle_get(conn, project_id, needle, order_by, order_dir, offset, limit)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, project_id, needle, order_by, order_dir, offset, limit) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group_roles_for_project", args: [project_id, needle, order_by, order_dir, offset, limit, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAdminService.Impl.get_personnel_group_roles_for_project(project_id, needle, order_by, order_dir, offset, limit, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group_roles_for_project", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.CollectionSlice, {{:custom, DbProtocol.PersonnelGroupRole}}})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group_roles_for_project", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group_roles_for_project", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule AdminPersonnelGroupRole do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        id = Igor.Json.parse_field!(conn.path_params, "id", :long)
        project_id = Igor.Json.parse_field!(conn.path_params, "project_id", :long)
        {conn, id, project_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, id, project_id} ->
          handle_get(conn, id, project_id)
      end
    end
    defp handle_method("PUT", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, WebProtocol.AccessRoleUpdateRequest})
        id = Igor.Json.parse_field!(conn.path_params, "id", :long)
        project_id = Igor.Json.parse_field!(conn.path_params, "project_id", :long)
        {conn, request, id, project_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request, id, project_id} ->
          handle_put(conn, request, id, project_id)
      end
    end
    defp handle_method("DELETE", conn) do
      try do
        id = Igor.Json.parse_field!(conn.path_params, "id", :long)
        project_id = Igor.Json.parse_field!(conn.path_params, "project_id", :long)
        {conn, id, project_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, id, project_id} ->
          handle_delete(conn, id, project_id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET, PUT, DELETE")
        |> send_resp(405, "")
    end

    defp handle_get(conn, id, project_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group_role", args: [id, project_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAdminService.Impl.get_personnel_group_role(id, project_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group_role", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DbProtocol.PersonnelGroupRole})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group_role", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group_role", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_personnel_group_role", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

    defp handle_put(conn, request, id, project_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAdminService.Impl.set_personnel_group_role", args: [request, id, project_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAdminService.Impl.set_personnel_group_role(request, id, project_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAdminService.Impl.set_personnel_group_role", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.GenericResponse})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.set_personnel_group_role", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.set_personnel_group_role", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.set_personnel_group_role", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

    defp handle_delete(conn, id, project_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAdminService.Impl.reset_personnel_group_role", args: [id, project_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAdminService.Impl.reset_personnel_group_role(id, project_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAdminService.Impl.reset_personnel_group_role", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.GenericResponse})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.reset_personnel_group_role", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.reset_personnel_group_role", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.reset_personnel_group_role", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule AdminSettings do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      handle_get(conn)
    end
    defp handle_method("PUT", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, WebProtocol.SettingsUpdateRequest})
        {conn, request}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request} ->
          handle_put(conn, request)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET, PUT")
        |> send_resp(405, "")
    end

    defp handle_get(conn) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAdminService.Impl.get_settings", args: [get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAdminService.Impl.get_settings(get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAdminService.Impl.get_settings", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, WebProtocol.Settings})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_settings", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.get_settings", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

    defp handle_put(conn, request) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAdminService.Impl.update_settings", args: [request, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAdminService.Impl.update_settings(request, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAdminService.Impl.update_settings", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.GenericResponse})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.update_settings", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAdminService.Impl.update_settings", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  @doc """
  Get single personnel account
  """
  @callback get_personnel_account(integer, session :: any()) :: DbProtocol.PersonnelAccount.t()

  @doc """
  Update personnel account
  """
  @callback update_personnel_account(WebProtocol.UpdatePersonnelAccountRequest.t(), integer, session :: any()) :: DbProtocol.PersonnelAccount.t()

  @doc """
  Get single personnel account by username
  """
  @callback get_personnel_account_by_username(String.t(), session :: any()) :: DbProtocol.PersonnelAccount.t()

  @doc """
  Get slice of personnel account collection
  """
  @callback get_personnel_accounts(String.t() | nil, WebProtocol.PersonnelAccountOrderBy.t(), DataProtocol.OrderDirection.t(), integer, integer, session :: any()) :: DataProtocol.CollectionSlice.t(DbProtocol.PersonnelAccount.t())

  @doc """
  Get slice of personnel account role collection
  """
  @callback get_personnel_account_roles(integer, String.t() | nil, WebProtocol.PersonnelAccountRoleOrderBy.t(), DataProtocol.OrderDirection.t(), integer, integer, session :: any()) :: DataProtocol.CollectionSlice.t(DbProtocol.PersonnelAccountRole.t())

  @doc """
  Get slice of collection of personnel account roles on a project
  """
  @callback get_personnel_account_roles_for_project(integer, String.t() | nil, WebProtocol.PersonnelAccountRoleOrderBy.t(), DataProtocol.OrderDirection.t(), integer, integer, session :: any()) :: DataProtocol.CollectionSlice.t(DbProtocol.PersonnelAccountRole.t())

  @doc """
  Get personnel account role
  """
  @callback get_personnel_account_role(integer, integer, session :: any()) :: DbProtocol.PersonnelAccountRole.t()

  @doc """
  Set personnel account role
  """
  @callback set_personnel_account_role(WebProtocol.AccessRoleUpdateRequest.t(), integer, integer, session :: any()) :: DataProtocol.GenericResponse.t()

  @doc """
  Reset personnel account role
  """
  @callback reset_personnel_account_role(integer, integer, session :: any()) :: DataProtocol.GenericResponse.t()

  @doc """
  Get single personnel group
  """
  @callback get_personnel_group(integer, session :: any()) :: DbProtocol.PersonnelGroup.t()

  @doc """
  Get single personnel group by name
  """
  @callback get_personnel_group_by_name(String.t(), session :: any()) :: DbProtocol.PersonnelGroup.t()

  @doc """
  Get slice of personnel group collection
  """
  @callback get_personnel_groups(String.t() | nil, WebProtocol.PersonnelGroupOrderBy.t(), DataProtocol.OrderDirection.t(), integer, integer, session :: any()) :: DataProtocol.CollectionSlice.t(DbProtocol.PersonnelGroup.t())

  @doc """
  Get slice of personnel group role collection
  """
  @callback get_personnel_group_roles(integer, String.t() | nil, WebProtocol.PersonnelGroupRoleOrderBy.t(), DataProtocol.OrderDirection.t(), integer, integer, session :: any()) :: DataProtocol.CollectionSlice.t(DbProtocol.PersonnelGroupRole.t())

  @callback get_personnel_group_roles_for_project(integer, String.t() | nil, WebProtocol.PersonnelGroupRoleOrderBy.t(), DataProtocol.OrderDirection.t(), integer, integer, session :: any()) :: DataProtocol.CollectionSlice.t(DbProtocol.PersonnelGroupRole.t())

  @doc """
  Get personnel group role
  """
  @callback get_personnel_group_role(integer, integer, session :: any()) :: DbProtocol.PersonnelGroupRole.t()

  @doc """
  Set personnel group role
  """
  @callback set_personnel_group_role(WebProtocol.AccessRoleUpdateRequest.t(), integer, integer, session :: any()) :: DataProtocol.GenericResponse.t()

  @doc """
  Reset personnel group role
  """
  @callback reset_personnel_group_role(integer, integer, session :: any()) :: DataProtocol.GenericResponse.t()

  @doc """
  Get settings
  """
  @callback get_settings(session :: any()) :: WebProtocol.Settings.t()

  @doc """
  Update settings
  """
  @callback update_settings(WebProtocol.SettingsUpdateRequest.t(), session :: any()) :: DataProtocol.GenericResponse.t()

end
