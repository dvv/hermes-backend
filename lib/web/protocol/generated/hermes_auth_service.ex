# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule WebProtocol.HermesAuthService do

  defmodule GetPersonnelStatus do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      handle_get(conn)
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAuthService.Impl.get_personnel_status", args: [get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAuthService.Impl.get_personnel_status(get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAuthService.Impl.get_personnel_status", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, WebProtocol.PersonnelStatusResponse})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAuthService.Impl.get_personnel_status", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule LoginPersonnel do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("POST", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, WebProtocol.PersonnelLoginRequest})
        {conn, request}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request} ->
          handle_post(conn, request)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "POST")
        |> send_resp(405, "")
    end

    defp handle_post(conn, request) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAuthService.Impl.login_personnel", args: [request]}, domain: [:rpc])
      {response_content, conn} = WebProtocol.HermesAuthService.Impl.login_personnel(request, conn)
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAuthService.Impl.login_personnel", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, WebProtocol.PersonnelLoginResponse})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.BadRequestError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAuthService.Impl.login_personnel", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.BadRequestError, {{:custom, WebProtocol.PersonnelLoginError}}})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(400, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAuthService.Impl.login_personnel", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule LogoutPersonnel do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("PUT", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, CommonProtocol.Empty})
        {conn, request}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request} ->
          handle_put(conn, request)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "PUT")
        |> send_resp(405, "")
    end

    defp handle_put(conn, request) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAuthService.Impl.logout_personnel", args: [request]}, domain: [:rpc])
      {response_content, conn} = WebProtocol.HermesAuthService.Impl.logout_personnel(request, conn)
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAuthService.Impl.logout_personnel", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.GenericResponse})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAuthService.Impl.logout_personnel", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule GetMyPersonnelProfile do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      handle_get(conn)
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAuthService.Impl.get_my_personnel_profile", args: [get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAuthService.Impl.get_my_personnel_profile(get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAuthService.Impl.get_my_personnel_profile", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DbProtocol.PersonnelAccount})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAuthService.Impl.get_my_personnel_profile", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAuthService.Impl.get_my_personnel_profile", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule GetMyRolesForProject do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        project_id = Igor.Json.parse_field!(conn.path_params, "project_id", :long)
        {conn, project_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, project_id} ->
          handle_get(conn, project_id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, project_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesAuthService.Impl.get_my_roles_for_project", args: [project_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesAuthService.Impl.get_my_roles_for_project(project_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesAuthService.Impl.get_my_roles_for_project", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DbProtocol.PersonnelAccountRole})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAuthService.Impl.get_my_roles_for_project", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesAuthService.Impl.get_my_roles_for_project", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesAuthService.Impl.get_my_roles_for_project", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  @doc """
  Get current personnel session status
  """
  @callback get_personnel_status(session :: any()) :: WebProtocol.PersonnelStatusResponse.t()

  @doc """
  Login personnel
  """
  @callback login_personnel(WebProtocol.PersonnelLoginRequest.t(), Plug.Conn.t()) :: {WebProtocol.PersonnelLoginResponse.t(), Plug.Conn.t()}

  @doc """
  Logout personnel
  """
  @callback logout_personnel(CommonProtocol.Empty.t(), Plug.Conn.t()) :: {DataProtocol.GenericResponse.t(), Plug.Conn.t()}

  @doc """
  Get current personnel profile
  """
  @callback get_my_personnel_profile(session :: any()) :: DbProtocol.PersonnelAccount.t()

  @doc """
  Get current personnel roles for a project
  """
  @callback get_my_roles_for_project(integer, session :: any()) :: DbProtocol.PersonnelAccountRole.t()

end
