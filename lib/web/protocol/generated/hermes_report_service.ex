# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule WebProtocol.HermesReportService do

  defmodule VismaReportsForOffice do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        year = Igor.Json.parse_field!(conn.path_params, "year", :int)
        month = Igor.Json.parse_field!(conn.path_params, "month", :int)
        office_id = Igor.Json.parse_field!(conn.path_params, "office_id", :long)
        {conn, year, month, office_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, year, month, office_id} ->
          handle_get(conn, year, month, office_id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, year, month, office_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesReportService.Impl.get_visma_reports_for_office", args: [year, month, office_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesReportService.Impl.get_visma_reports_for_office(year, month, office_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesReportService.Impl.get_visma_reports_for_office", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.Collection, {{:custom, DbProtocol.VismaReport}}})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.get_visma_reports_for_office", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.get_visma_reports_for_office", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule VismaReport do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        report_id = Igor.Json.parse_field!(conn.path_params, "report_id", :long)
        {conn, report_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, report_id} ->
          handle_get(conn, report_id)
      end
    end
    defp handle_method("PUT", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request_content = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, WebProtocol.UpdateVismaReportRequest})
        report_id = Igor.Json.parse_field!(conn.path_params, "report_id", :long)
        {conn, request_content, report_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request_content, report_id} ->
          handle_put(conn, request_content, report_id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET, PUT")
        |> send_resp(405, "")
    end

    defp handle_get(conn, report_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesReportService.Impl.get_visma_report", args: [report_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesReportService.Impl.get_visma_report(report_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesReportService.Impl.get_visma_report", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DbProtocol.VismaReport})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.get_visma_report", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.get_visma_report", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.get_visma_report", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

    defp handle_put(conn, request_content, report_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesReportService.Impl.update_visma_report", args: [request_content, report_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesReportService.Impl.update_visma_report(request_content, report_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesReportService.Impl.update_visma_report", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DbProtocol.VismaReport})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.update_visma_report", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.BadRequestError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.update_visma_report", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.BadRequestError, {{:custom, WebProtocol.VismaReportError}}})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(400, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.update_visma_report", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.update_visma_report", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule VismaReports do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("POST", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request_content = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, WebProtocol.CreateVismaReportRequest})
        {conn, request_content}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request_content} ->
          handle_post(conn, request_content)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "POST")
        |> send_resp(405, "")
    end

    defp handle_post(conn, request_content) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesReportService.Impl.create_visma_report", args: [request_content, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesReportService.Impl.create_visma_report(request_content, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesReportService.Impl.create_visma_report", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DbProtocol.VismaReport})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(201, body)
    rescue
      e in DataProtocol.BadRequestError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.create_visma_report", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.BadRequestError, {{:custom, WebProtocol.VismaReportError}}})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(400, body)
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.create_visma_report", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.create_visma_report", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule VismaReportDownload do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        report_id = Igor.Json.parse_field!(conn.path_params, "report_id", :long)
        {conn, report_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, report_id} ->
          handle_get(conn, report_id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, report_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesReportService.Impl.download_visma_report", args: [report_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesReportService.Impl.download_visma_report(report_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesReportService.Impl.download_visma_report", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value(:json)
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/octet-stream")
        |> put_resp_header("Content-Disposition", "attachment; filename=\"visma_report.json\"")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.download_visma_report", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.download_visma_report", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.download_visma_report", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule VismaReportDelivery do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("POST", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request_content = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, CommonProtocol.Empty})
        report_id = Igor.Json.parse_field!(conn.path_params, "report_id", :long)
        {conn, request_content, report_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request_content, report_id} ->
          handle_post(conn, request_content, report_id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "POST")
        |> send_resp(405, "")
    end

    defp handle_post(conn, request_content, report_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesReportService.Impl.deliver_visma_report", args: [request_content, report_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesReportService.Impl.deliver_visma_report(request_content, report_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesReportService.Impl.deliver_visma_report", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DbProtocol.VismaReport})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.BadRequestError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.deliver_visma_report", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.BadRequestError, {{:custom, WebProtocol.VismaReportDeliveryError}}})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(400, body)
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.deliver_visma_report", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.deliver_visma_report", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.deliver_visma_report", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule VismaReportDeliveryStatus do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("POST", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request_content = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, CommonProtocol.Empty})
        report_id = Igor.Json.parse_field!(conn.path_params, "report_id", :long)
        {conn, request_content, report_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request_content, report_id} ->
          handle_post(conn, request_content, report_id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "POST")
        |> send_resp(405, "")
    end

    defp handle_post(conn, request_content, report_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesReportService.Impl.update_visma_report_delivery_status", args: [request_content, report_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesReportService.Impl.update_visma_report_delivery_status(request_content, report_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesReportService.Impl.update_visma_report_delivery_status", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DbProtocol.VismaReport})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.BadRequestError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.update_visma_report_delivery_status", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.BadRequestError, {{:custom, WebProtocol.VismaReportDeliveryError}}})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(400, body)
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.update_visma_report_delivery_status", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.update_visma_report_delivery_status", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.update_visma_report_delivery_status", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule VismaReportOmittedEmployees do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        office_id = Igor.Json.parse_field!(conn.path_params, "office_id", :long)
        {conn, office_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, office_id} ->
          handle_get(conn, office_id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, office_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesReportService.Impl.get_omitted_employees_for_last_visma_report", args: [office_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesReportService.Impl.get_omitted_employees_for_last_visma_report(office_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesReportService.Impl.get_omitted_employees_for_last_visma_report", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, WebProtocol.OmittedEmployees})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.get_omitted_employees_for_last_visma_report", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.get_omitted_employees_for_last_visma_report", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesReportService.Impl.get_omitted_employees_for_last_visma_report", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  @doc """
  Get monthly visma reports for particular office
  """
  @callback get_visma_reports_for_office(integer, integer, integer, session :: any()) :: DataProtocol.Collection.t(DbProtocol.VismaReport.t())

  @doc """
  Get visma report
  """
  @callback get_visma_report(integer, session :: any()) :: DbProtocol.VismaReport.t()

  @doc """
  Update visma report
  """
  @callback update_visma_report(WebProtocol.UpdateVismaReportRequest.t(), integer, session :: any()) :: DbProtocol.VismaReport.t()

  @doc """
  Create monthly visma report for particular office
  """
  @callback create_visma_report(WebProtocol.CreateVismaReportRequest.t(), session :: any()) :: DbProtocol.VismaReport.t()

  @doc """
  Get visma report details
  """
  @callback download_visma_report(integer, session :: any()) :: Igor.Json.json()

  @doc """
  Deliver Visma report to Visma through Junipeer
  """
  @callback deliver_visma_report(CommonProtocol.Empty.t(), integer, session :: any()) :: DbProtocol.VismaReport.t()

  @doc """
  Update Visma report delivery status from Junipeer
  """
  @callback update_visma_report_delivery_status(CommonProtocol.Empty.t(), integer, session :: any()) :: DbProtocol.VismaReport.t()

  @doc """
  Get omitted employees for last Visma report
  """
  @callback get_omitted_employees_for_last_visma_report(integer, session :: any()) :: WebProtocol.OmittedEmployees.t()

end
