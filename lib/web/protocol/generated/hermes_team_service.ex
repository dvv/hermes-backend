# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule WebProtocol.HermesTeamService do

  defmodule Teams do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      handle_get(conn)
    end
    defp handle_method("POST", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request_content = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, WebProtocol.CreateTeamRequest})
        {conn, request_content}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request_content} ->
          handle_post(conn, request_content)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET, POST")
        |> send_resp(405, "")
    end

    defp handle_get(conn) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTeamService.Impl.get_teams", args: [get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTeamService.Impl.get_teams(get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTeamService.Impl.get_teams", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.Collection, {{:custom, DbProtocol.Team}}})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.get_teams", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.get_teams", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

    defp handle_post(conn, request_content) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTeamService.Impl.create_team", args: [request_content, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTeamService.Impl.create_team(request_content, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTeamService.Impl.create_team", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DbProtocol.Team})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.BadRequestError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.create_team", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.BadRequestError, {{:custom, WebProtocol.TeamError}}})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(400, body)
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.create_team", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.create_team", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule Team do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        id = Igor.Json.parse_field!(conn.path_params, "id", :long)
        {conn, id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, id} ->
          handle_get(conn, id)
      end
    end
    defp handle_method("PUT", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request_content = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, WebProtocol.UpdateTeamRequest})
        id = Igor.Json.parse_field!(conn.path_params, "id", :long)
        {conn, request_content, id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request_content, id} ->
          handle_put(conn, request_content, id)
      end
    end
    defp handle_method("DELETE", conn) do
      try do
        id = Igor.Json.parse_field!(conn.path_params, "id", :long)
        {conn, id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, id} ->
          handle_delete(conn, id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET, PUT, DELETE")
        |> send_resp(405, "")
    end

    defp handle_get(conn, id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTeamService.Impl.get_team", args: [id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTeamService.Impl.get_team(id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTeamService.Impl.get_team", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DbProtocol.Team})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.get_team", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.get_team", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.get_team", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

    defp handle_put(conn, request_content, id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTeamService.Impl.update_team", args: [request_content, id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTeamService.Impl.update_team(request_content, id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTeamService.Impl.update_team", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DbProtocol.Team})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.BadRequestError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.update_team", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.BadRequestError, {{:custom, WebProtocol.TeamError}}})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(400, body)
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.update_team", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.update_team", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.update_team", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

    defp handle_delete(conn, id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTeamService.Impl.delete_team", args: [id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTeamService.Impl.delete_team(id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTeamService.Impl.delete_team", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.GenericResponse})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.delete_team", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.delete_team", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.delete_team", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule TeamMember do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("PUT", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request_content = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, CommonProtocol.Empty})
        team_id = Igor.Json.parse_field!(conn.path_params, "team_id", :long)
        personnel_id = Igor.Json.parse_field!(conn.path_params, "personnel_id", :long)
        {conn, request_content, team_id, personnel_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request_content, team_id, personnel_id} ->
          handle_put(conn, request_content, team_id, personnel_id)
      end
    end
    defp handle_method("DELETE", conn) do
      try do
        team_id = Igor.Json.parse_field!(conn.path_params, "team_id", :long)
        personnel_id = Igor.Json.parse_field!(conn.path_params, "personnel_id", :long)
        {conn, team_id, personnel_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, team_id, personnel_id} ->
          handle_delete(conn, team_id, personnel_id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "PUT, DELETE")
        |> send_resp(405, "")
    end

    defp handle_put(conn, request_content, team_id, personnel_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTeamService.Impl.add_team_member", args: [request_content, team_id, personnel_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTeamService.Impl.add_team_member(request_content, team_id, personnel_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTeamService.Impl.add_team_member", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.GenericResponse})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.BadRequestError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.add_team_member", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.BadRequestError, {{:custom, WebProtocol.TeamMemberError}}})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(400, body)
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.add_team_member", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.add_team_member", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.add_team_member", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

    defp handle_delete(conn, team_id, personnel_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTeamService.Impl.remove_team_member", args: [team_id, personnel_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTeamService.Impl.remove_team_member(team_id, personnel_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTeamService.Impl.remove_team_member", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.GenericResponse})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.BadRequestError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.remove_team_member", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.BadRequestError, {{:custom, WebProtocol.TeamMemberError}}})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(400, body)
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.remove_team_member", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.remove_team_member", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.remove_team_member", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule TeamManagers do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        team_id = Igor.Json.parse_field!(conn.path_params, "team_id", :long)
        {conn, team_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, team_id} ->
          handle_get(conn, team_id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, team_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTeamService.Impl.get_team_managers", args: [team_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTeamService.Impl.get_team_managers(team_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTeamService.Impl.get_team_managers", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.Collection, {{:custom, DbProtocol.PersonnelAccount}}})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.get_team_managers", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.get_team_managers", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.get_team_managers", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule IsCurrentUserTeamManager do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        team_id = Igor.Json.parse_field!(conn.path_params, "team_id", :long)
        {conn, team_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, team_id} ->
          handle_get(conn, team_id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, team_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTeamService.Impl.is_current_user_team_manager", args: [team_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTeamService.Impl.is_current_user_team_manager(team_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTeamService.Impl.is_current_user_team_manager", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.GenericResponse})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.is_current_user_team_manager", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.is_current_user_team_manager", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.is_current_user_team_manager", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule TeamManager do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        team_id = Igor.Json.parse_field!(conn.path_params, "team_id", :long)
        personnel_id = Igor.Json.parse_field!(conn.path_params, "personnel_id", :long)
        {conn, team_id, personnel_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, team_id, personnel_id} ->
          handle_get(conn, team_id, personnel_id)
      end
    end
    defp handle_method("PUT", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request_content = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, CommonProtocol.Empty})
        team_id = Igor.Json.parse_field!(conn.path_params, "team_id", :long)
        personnel_id = Igor.Json.parse_field!(conn.path_params, "personnel_id", :long)
        {conn, request_content, team_id, personnel_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request_content, team_id, personnel_id} ->
          handle_put(conn, request_content, team_id, personnel_id)
      end
    end
    defp handle_method("DELETE", conn) do
      try do
        team_id = Igor.Json.parse_field!(conn.path_params, "team_id", :long)
        personnel_id = Igor.Json.parse_field!(conn.path_params, "personnel_id", :long)
        {conn, team_id, personnel_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, team_id, personnel_id} ->
          handle_delete(conn, team_id, personnel_id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET, PUT, DELETE")
        |> send_resp(405, "")
    end

    defp handle_get(conn, team_id, personnel_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTeamService.Impl.is_team_manager", args: [team_id, personnel_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTeamService.Impl.is_team_manager(team_id, personnel_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTeamService.Impl.is_team_manager", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.GenericResponse})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.is_team_manager", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.is_team_manager", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.is_team_manager", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

    defp handle_put(conn, request_content, team_id, personnel_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTeamService.Impl.set_team_manager", args: [request_content, team_id, personnel_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTeamService.Impl.set_team_manager(request_content, team_id, personnel_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTeamService.Impl.set_team_manager", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.GenericResponse})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.BadRequestError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.set_team_manager", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.BadRequestError, {{:custom, WebProtocol.TeamManagerError}}})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(400, body)
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.set_team_manager", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.set_team_manager", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.set_team_manager", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

    defp handle_delete(conn, team_id, personnel_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTeamService.Impl.unset_team_manager", args: [team_id, personnel_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTeamService.Impl.unset_team_manager(team_id, personnel_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTeamService.Impl.unset_team_manager", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.GenericResponse})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.BadRequestError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.unset_team_manager", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.BadRequestError, {{:custom, WebProtocol.TeamManagerError}}})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(400, body)
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.unset_team_manager", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.unset_team_manager", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTeamService.Impl.unset_team_manager", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  @doc """
  Get teams
  """
  @callback get_teams(session :: any()) :: DataProtocol.Collection.t(DbProtocol.Team.t())

  @doc """
  Create a team
  """
  @callback create_team(WebProtocol.CreateTeamRequest.t(), session :: any()) :: DbProtocol.Team.t()

  @doc """
  Get a team
  """
  @callback get_team(integer, session :: any()) :: DbProtocol.Team.t()

  @doc """
  Update a team
  """
  @callback update_team(WebProtocol.UpdateTeamRequest.t(), integer, session :: any()) :: DbProtocol.Team.t()

  @doc """
  Delete a team
  """
  @callback delete_team(integer, session :: any()) :: DataProtocol.GenericResponse.t()

  @doc """
  Add user to a team
  """
  @callback add_team_member(CommonProtocol.Empty.t(), integer, integer, session :: any()) :: DataProtocol.GenericResponse.t()

  @doc """
  Remove user from a team
  """
  @callback remove_team_member(integer, integer, session :: any()) :: DataProtocol.GenericResponse.t()

  @doc """
  Get a list of team managers
  """
  @callback get_team_managers(integer, session :: any()) :: DataProtocol.Collection.t(DbProtocol.PersonnelAccount.t())

  @doc """
  Check if current user is a team manager
  """
  @callback is_current_user_team_manager(integer, session :: any()) :: DataProtocol.GenericResponse.t()

  @doc """
  Check if user is a team manager
  """
  @callback is_team_manager(integer, integer, session :: any()) :: DataProtocol.GenericResponse.t()

  @doc """
  Set user as a team manager
  """
  @callback set_team_manager(CommonProtocol.Empty.t(), integer, integer, session :: any()) :: DataProtocol.GenericResponse.t()

  @doc """
  Unset user as a team manager
  """
  @callback unset_team_manager(integer, integer, session :: any()) :: DataProtocol.GenericResponse.t()

end
