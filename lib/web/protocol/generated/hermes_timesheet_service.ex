# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule WebProtocol.HermesTimesheetService do

  defmodule TimesheetCell do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        cell_id = Igor.Json.parse_field!(conn.path_params, "cell_id", :long)
        {conn, cell_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, cell_id} ->
          handle_get(conn, cell_id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, cell_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_timesheet_cell", args: [cell_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTimesheetService.Impl.get_timesheet_cell(cell_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_timesheet_cell", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DbProtocol.TimesheetCell})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_timesheet_cell", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_timesheet_cell", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_timesheet_cell", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule TimesheetBulkAllocate do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("PUT", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request_content = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, WebProtocol.BulkTimesheetAllocate})
        {conn, request_content}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request_content} ->
          handle_put(conn, request_content)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "PUT")
        |> send_resp(405, "")
    end

    defp handle_put(conn, request_content) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTimesheetService.Impl.allocate_timesheet_cell_bulk", args: [request_content, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTimesheetService.Impl.allocate_timesheet_cell_bulk(request_content, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTimesheetService.Impl.allocate_timesheet_cell_bulk", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:list, {:custom, DbProtocol.TimesheetCell}})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.BadRequestError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.allocate_timesheet_cell_bulk", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.BadRequestError, {{:custom, WebProtocol.TimesheetCellAllocError}}})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(400, body)
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.allocate_timesheet_cell_bulk", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.allocate_timesheet_cell_bulk", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule TimesheetBulkReset do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("PUT", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request_content = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, WebProtocol.BulkTimesheetAction})
        {conn, request_content}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request_content} ->
          handle_put(conn, request_content)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "PUT")
        |> send_resp(405, "")
    end

    defp handle_put(conn, request_content) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTimesheetService.Impl.reset_timesheet_cell_bulk", args: [request_content, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTimesheetService.Impl.reset_timesheet_cell_bulk(request_content, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTimesheetService.Impl.reset_timesheet_cell_bulk", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:list, {:custom, DbProtocol.TimesheetCell}})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.reset_timesheet_cell_bulk", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.reset_timesheet_cell_bulk", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule TimesheetBulkTimeOff do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("PUT", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request_content = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, WebProtocol.BulkTimesheetTimeOff})
        {conn, request_content}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request_content} ->
          handle_put(conn, request_content)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "PUT")
        |> send_resp(405, "")
    end

    defp handle_put(conn, request_content) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTimesheetService.Impl.set_timesheet_cell_off_bulk", args: [request_content, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTimesheetService.Impl.set_timesheet_cell_off_bulk(request_content, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTimesheetService.Impl.set_timesheet_cell_off_bulk", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:list, {:custom, DbProtocol.TimesheetCell}})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.BadRequestError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.set_timesheet_cell_off_bulk", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.BadRequestError, {{:custom, WebProtocol.TimesheetCellOffError}}})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(400, body)
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.set_timesheet_cell_off_bulk", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.set_timesheet_cell_off_bulk", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule TimesheetBulkProtect do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("PUT", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request_content = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, WebProtocol.BulkTimesheetProtect})
        {conn, request_content}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request_content} ->
          handle_put(conn, request_content)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "PUT")
        |> send_resp(405, "")
    end

    defp handle_put(conn, request_content) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTimesheetService.Impl.protect_timesheet_cell_bulk", args: [request_content, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTimesheetService.Impl.protect_timesheet_cell_bulk(request_content, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTimesheetService.Impl.protect_timesheet_cell_bulk", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:list, {:custom, DbProtocol.TimesheetCell}})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.protect_timesheet_cell_bulk", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.protect_timesheet_cell_bulk", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule TimesheetBulkUnprotect do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("PUT", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request_content = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, WebProtocol.BulkTimesheetProtect})
        {conn, request_content}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request_content} ->
          handle_put(conn, request_content)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "PUT")
        |> send_resp(405, "")
    end

    defp handle_put(conn, request_content) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTimesheetService.Impl.unprotect_timesheet_cell_bulk", args: [request_content, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTimesheetService.Impl.unprotect_timesheet_cell_bulk(request_content, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTimesheetService.Impl.unprotect_timesheet_cell_bulk", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:list, {:custom, DbProtocol.TimesheetCell}})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.unprotect_timesheet_cell_bulk", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.unprotect_timesheet_cell_bulk", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule TimesheetRegenerate do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("PUT", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request_content = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, CommonProtocol.Empty})
        year = Igor.Json.parse_field!(conn.path_params, "year", :int)
        month = Igor.Json.parse_field!(conn.path_params, "month", :int)
        {conn, request_content, year, month}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request_content, year, month} ->
          handle_put(conn, request_content, year, month)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "PUT")
        |> send_resp(405, "")
    end

    defp handle_put(conn, request_content, year, month) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTimesheetService.Impl.regenerate_timesheet_cells", args: [request_content, year, month, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTimesheetService.Impl.regenerate_timesheet_cells(request_content, year, month, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTimesheetService.Impl.regenerate_timesheet_cells", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.GenericResponse})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.regenerate_timesheet_cells", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.regenerate_timesheet_cells", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule TimesheetCellProtectMonthForEmployee do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("PUT", conn) do
      try do
        {:ok, body, conn} = read_body(conn)
        request_content = body
          |> Igor.Json.decode!()
          |> Igor.Json.parse_value!({:custom, CommonProtocol.Empty})
        year = Igor.Json.parse_field!(conn.path_params, "year", :int)
        month = Igor.Json.parse_field!(conn.path_params, "month", :int)
        personnel_id = Igor.Json.parse_field!(conn.path_params, "personnel_id", :long)
        {conn, request_content, year, month, personnel_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, request_content, year, month, personnel_id} ->
          handle_put(conn, request_content, year, month, personnel_id)
      end
    end
    defp handle_method("DELETE", conn) do
      try do
        year = Igor.Json.parse_field!(conn.path_params, "year", :int)
        month = Igor.Json.parse_field!(conn.path_params, "month", :int)
        personnel_id = Igor.Json.parse_field!(conn.path_params, "personnel_id", :long)
        {conn, year, month, personnel_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, year, month, personnel_id} ->
          handle_delete(conn, year, month, personnel_id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "PUT, DELETE")
        |> send_resp(405, "")
    end

    defp handle_put(conn, request_content, year, month, personnel_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTimesheetService.Impl.protect_timesheet_month_for_employee", args: [request_content, year, month, personnel_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTimesheetService.Impl.protect_timesheet_month_for_employee(request_content, year, month, personnel_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTimesheetService.Impl.protect_timesheet_month_for_employee", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.GenericResponse})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.protect_timesheet_month_for_employee", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.protect_timesheet_month_for_employee", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.protect_timesheet_month_for_employee", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

    defp handle_delete(conn, year, month, personnel_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTimesheetService.Impl.unprotect_timesheet_month_for_employee", args: [year, month, personnel_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTimesheetService.Impl.unprotect_timesheet_month_for_employee(year, month, personnel_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTimesheetService.Impl.unprotect_timesheet_month_for_employee", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.GenericResponse})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.unprotect_timesheet_month_for_employee", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.unprotect_timesheet_month_for_employee", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.unprotect_timesheet_month_for_employee", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule MonthlyEmployeeTimesheet do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        year = Igor.Json.parse_field!(conn.path_params, "year", :int)
        month = Igor.Json.parse_field!(conn.path_params, "month", :int)
        personnel_id = Igor.Json.parse_field!(conn.path_params, "personnel_id", :long)
        {conn, year, month, personnel_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, year, month, personnel_id} ->
          handle_get(conn, year, month, personnel_id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, year, month, personnel_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_employee", args: [year, month, personnel_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_employee(year, month, personnel_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_employee", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, WebProtocol.MonthlyEmployeeTimesheet})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_employee", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_employee", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_employee", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule MonthlyProjectTimesheet do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        year = Igor.Json.parse_field!(conn.path_params, "year", :int)
        month = Igor.Json.parse_field!(conn.path_params, "month", :int)
        project_id = Igor.Json.parse_field!(conn.path_params, "project_id", :long)
        {conn, year, month, project_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, year, month, project_id} ->
          handle_get(conn, year, month, project_id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, year, month, project_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_project", args: [year, month, project_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_project(year, month, project_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_project", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.Collection, {{:custom, WebProtocol.MonthlyEmployeeTimesheet}}})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_project", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_project", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_project", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule MonthlyOfficeTimesheet do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        year = Igor.Json.parse_field!(conn.path_params, "year", :int)
        month = Igor.Json.parse_field!(conn.path_params, "month", :int)
        office_id = Igor.Json.parse_field!(conn.path_params, "office_id", :long)
        {conn, year, month, office_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, year, month, office_id} ->
          handle_get(conn, year, month, office_id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, year, month, office_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_office", args: [year, month, office_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_office(year, month, office_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_office", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.Collection, {{:custom, WebProtocol.MonthlyEmployeeTimesheet}}})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_office", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_office", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_office", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule MonthlyTeamTimesheet do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        year = Igor.Json.parse_field!(conn.path_params, "year", :int)
        month = Igor.Json.parse_field!(conn.path_params, "month", :int)
        team_id = Igor.Json.parse_field!(conn.path_params, "team_id", :long)
        {conn, year, month, team_id}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, year, month, team_id} ->
          handle_get(conn, year, month, team_id)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, year, month, team_id) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_team", args: [year, month, team_id, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_team(year, month, team_id, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_team", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.Collection, {{:custom, WebProtocol.MonthlyEmployeeTimesheet}}})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_team", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_team", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_team", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule MonthlyEveryoneTimesheet do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        year = Igor.Json.parse_field!(conn.path_params, "year", :int)
        month = Igor.Json.parse_field!(conn.path_params, "month", :int)
        {conn, year, month}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, year, month} ->
          handle_get(conn, year, month)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, year, month) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_everyone", args: [year, month, get_session(conn, :api)]}, domain: [:rpc])
      response_content = WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_everyone(year, month, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_everyone", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, DataProtocol.Collection, {{:custom, WebProtocol.MonthlyEmployeeTimesheet}}})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_everyone", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_everyone", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesTimesheetService.Impl.get_monthly_timesheet_for_everyone", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  @doc """
  Get a timesheet cell
  """
  @callback get_timesheet_cell(integer, session :: any()) :: DbProtocol.TimesheetCell.t()

  @doc """
  Allocate a lot of timesheet cells for a project
  """
  @callback allocate_timesheet_cell_bulk(WebProtocol.BulkTimesheetAllocate.t(), session :: any()) :: [DbProtocol.TimesheetCell.t()]

  @doc """
  Reset a lot of timesheet cells for a project
  """
  @callback reset_timesheet_cell_bulk(WebProtocol.BulkTimesheetAction.t(), session :: any()) :: [DbProtocol.TimesheetCell.t()]

  @doc """
  Set a time_off to a lot of timesheet cells
  """
  @callback set_timesheet_cell_off_bulk(WebProtocol.BulkTimesheetTimeOff.t(), session :: any()) :: [DbProtocol.TimesheetCell.t()]

  @doc """
  Protect a lot of timesheet cells from changes
  """
  @callback protect_timesheet_cell_bulk(WebProtocol.BulkTimesheetProtect.t(), session :: any()) :: [DbProtocol.TimesheetCell.t()]

  @doc """
  Remove protection from a lot of timesheet cells
  """
  @callback unprotect_timesheet_cell_bulk(WebProtocol.BulkTimesheetProtect.t(), session :: any()) :: [DbProtocol.TimesheetCell.t()]

  @doc """
  Regenerate timesheet cells for all employees for the period specified
  """
  @callback regenerate_timesheet_cells(CommonProtocol.Empty.t(), integer, integer, session :: any()) :: DataProtocol.GenericResponse.t()

  @doc """
  Protect a monthly range of timesheet cells for particular employee from changes
  """
  @callback protect_timesheet_month_for_employee(CommonProtocol.Empty.t(), integer, integer, integer, session :: any()) :: DataProtocol.GenericResponse.t()

  @doc """
  Remove protection from a monthly range of timesheet cells for particular employee
  """
  @callback unprotect_timesheet_month_for_employee(integer, integer, integer, session :: any()) :: DataProtocol.GenericResponse.t()

  @doc """
  Get monthly timesheet for specified year and month and employee
  """
  @callback get_monthly_timesheet_for_employee(integer, integer, integer, session :: any()) :: WebProtocol.MonthlyEmployeeTimesheet.t()

  @doc """
  Get monthly timesheet for specified year and month and project
  """
  @callback get_monthly_timesheet_for_project(integer, integer, integer, session :: any()) :: DataProtocol.Collection.t(WebProtocol.MonthlyEmployeeTimesheet.t())

  @doc """
  Get monthly timesheet for specified year and month and office
  """
  @callback get_monthly_timesheet_for_office(integer, integer, integer, session :: any()) :: DataProtocol.Collection.t(WebProtocol.MonthlyEmployeeTimesheet.t())

  @doc """
  Get monthly timesheet for specified year and month and team
  """
  @callback get_monthly_timesheet_for_team(integer, integer, integer, session :: any()) :: DataProtocol.Collection.t(WebProtocol.MonthlyEmployeeTimesheet.t())

  @doc """
  Get monthly timesheet for specified year and month for everyone
  """
  @callback get_monthly_timesheet_for_everyone(integer, integer, session :: any()) :: DataProtocol.Collection.t(WebProtocol.MonthlyEmployeeTimesheet.t())

end
