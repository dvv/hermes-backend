# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule HrveyProtocol do

  defmodule TimeOffEntry do

    @enforce_keys [:date, :type, :days, :note]
    defstruct [date: nil, type: nil, days: nil, note: nil]

    @type t :: %TimeOffEntry{date: HrveyProtocol.date(), type: String.t(), days: String.t(), note: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      date = Igor.Json.parse_field!(json, "date", {:custom, Util.Date})
      type = Igor.Json.parse_field!(json, "type", :string)
      days = Igor.Json.parse_field!(json, "days", :string)
      note = Igor.Json.parse_field!(json, "note", :string)
      %TimeOffEntry{
        date: date,
        type: type,
        days: days,
        note: note
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        date: date,
        type: type,
        days: days,
        note: note
      } = args
      %{
        "date" => Util.Date.to_json!(date),
        "type" => Igor.Json.pack_value(type, :string),
        "days" => Igor.Json.pack_value(days, :string),
        "note" => Igor.Json.pack_value(note, :string)
      }
    end

  end

  defmodule Employee do

    @enforce_keys [:employee_id, :name, :email, :office]
    defstruct [employee_id: nil, name: nil, email: nil, office: nil, team: nil, time_off: []]

    @type t :: %Employee{employee_id: String.t(), name: String.t(), email: String.t(), office: String.t(), team: String.t() | nil, time_off: [HrveyProtocol.TimeOffEntry.t()]}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      employee_id = Igor.Json.parse_field!(json, "employee_id", :string)
      name = Igor.Json.parse_field!(json, "name", :string)
      email = Igor.Json.parse_field!(json, "email", :string)
      office = Igor.Json.parse_field!(json, "office", :string)
      team = Igor.Json.parse_field!(json, "team", :string, nil)
      time_off = Igor.Json.parse_field!(json, "time_off", {:list, {:custom, HrveyProtocol.TimeOffEntry}}, [])
      %Employee{
        employee_id: employee_id,
        name: name,
        email: email,
        office: office,
        team: team,
        time_off: time_off
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        employee_id: employee_id,
        name: name,
        email: email,
        office: office,
        team: team,
        time_off: time_off
      } = args
      %{}
        |> Igor.Json.pack_field("employee_id", employee_id, :string)
        |> Igor.Json.pack_field("name", name, :string)
        |> Igor.Json.pack_field("email", email, :string)
        |> Igor.Json.pack_field("office", office, :string)
        |> Igor.Json.pack_field("team", team, :string)
        |> Igor.Json.pack_field("time_off", time_off, {:list, {:custom, HrveyProtocol.TimeOffEntry}})
    end

  end

  defmodule HrveyApi do

    @spec get_time_off_report(String.t(), boolean, HrveyProtocol.date(), HrveyProtocol.date(), String.t()) :: [HrveyProtocol.Employee.t()]
    def get_time_off_report(base_url, per_date, from, to, authorization) do
      query = Igor.Http.compose_query([{"per_date", per_date, :boolean}, {"from", from, :string}, {"to", to, :string}])
      request_headers = [{"accept", "application/json"}, {"authorization", authorization}]
      url = "#{base_url}/api_reports.json?#{query}"
      case HTTPoison.get(url, request_headers, []) do
        {:ok, %HTTPoison.Response{status_code: status_code, body: body}} when status_code < 300 ->
          body
            |> Igor.Json.decode!()
            |> Igor.Json.parse_value!({:list, {:custom, HrveyProtocol.Employee}})
        {:ok, %HTTPoison.Response{status_code: status_code, body: response_body, headers: response_headers}} ->
          raise %Igor.Http.HttpError{status_code: status_code, body: response_body, headers: response_headers}
        {:error, %HTTPoison.Error{reason: _} = e} ->
          raise e
      end
    end

  end

  @type date :: String.t()

end
