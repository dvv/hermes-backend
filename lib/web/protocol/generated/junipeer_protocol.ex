# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule JunipeerProtocol do

  defmodule ReportEnvelope do

    @enforce_keys [:country, :company_id, :data]
    defstruct [country: nil, company_id: nil, data: nil]

    @type t :: %ReportEnvelope{country: String.t(), company_id: String.t(), data: Igor.Json.json()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      country = Igor.Json.parse_field!(json, "country", :string)
      company_id = Igor.Json.parse_field!(json, "company_id", :string)
      data = Igor.Json.parse_field!(json, "data", :json)
      %ReportEnvelope{country: country, company_id: company_id, data: data}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{country: country, company_id: company_id, data: data} = args
      %{
        "country" => Igor.Json.pack_value(country, :string),
        "company_id" => Igor.Json.pack_value(company_id, :string),
        "data" => data
      }
    end

  end

  defmodule JunipeerError do

    defstruct [message: nil, code: nil, trace: nil]

    @type t :: %JunipeerError{message: String.t() | nil, code: integer | nil, trace: Igor.Json.json() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      message = Igor.Json.parse_field!(json, "message", :string, nil)
      code = Igor.Json.parse_field!(json, "code", :int, nil)
      trace = Igor.Json.parse_field!(json, "trace", :json, nil)
      %JunipeerError{message: message, code: code, trace: trace}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{message: message, code: code, trace: trace} = args
      %{}
        |> Igor.Json.pack_field("message", message, :string)
        |> Igor.Json.pack_field("code", code, :int)
        |> Igor.Json.pack_field("trace", trace, :json)
    end

  end

  defmodule SubmitReportResponse do

    @enforce_keys [:task_id]
    defstruct [task_id: nil]

    @type t :: %SubmitReportResponse{task_id: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      task_id = Igor.Json.parse_field!(json, "task_id", :string)
      %SubmitReportResponse{task_id: task_id}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{task_id: task_id} = args
      %{
        "task_id" => Igor.Json.pack_value(task_id, :string)
      }
    end

  end

  defmodule ReportProcessingStats do

    @enforce_keys [:total_succeeded, :total_ignored, :total_errors]
    defstruct [total_succeeded: nil, total_ignored: nil, total_errors: nil]

    @type t :: %ReportProcessingStats{total_succeeded: non_neg_integer, total_ignored: non_neg_integer, total_errors: non_neg_integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      total_succeeded = Igor.Json.parse_field!(json, "total_succeeded", :uint)
      total_ignored = Igor.Json.parse_field!(json, "total_ignored", :uint)
      total_errors = Igor.Json.parse_field!(json, "total_errors", :uint)
      %ReportProcessingStats{total_succeeded: total_succeeded, total_ignored: total_ignored, total_errors: total_errors}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{total_succeeded: total_succeeded, total_ignored: total_ignored, total_errors: total_errors} = args
      %{
        "total_succeeded" => Igor.Json.pack_value(total_succeeded, :uint),
        "total_ignored" => Igor.Json.pack_value(total_ignored, :uint),
        "total_errors" => Igor.Json.pack_value(total_errors, :uint)
      }
    end

  end

  defmodule ReportLogEntry do

    @enforce_keys [:message, :success, :created_at]
    defstruct [message: nil, success: nil, errors: nil, created_at: nil]

    @type t :: %ReportLogEntry{message: String.t(), success: boolean, errors: [String.t()] | nil, created_at: CommonProtocol.date_time()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      message = Igor.Json.parse_field!(json, "message", :string)
      success = Igor.Json.parse_field!(json, "success", :boolean)
      errors = Igor.Json.parse_field!(json, "errors", {:list, :string}, nil)
      created_at = Igor.Json.parse_field!(json, "created_at", {:custom, Util.DateTime})
      %ReportLogEntry{
        message: message,
        success: success,
        errors: errors,
        created_at: created_at
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        message: message,
        success: success,
        errors: errors,
        created_at: created_at
      } = args
      %{}
        |> Igor.Json.pack_field("message", message, :string)
        |> Igor.Json.pack_field("success", success, :boolean)
        |> Igor.Json.pack_field("errors", errors, {:list, :string})
        |> Igor.Json.pack_field("created_at", created_at, {:custom, Util.DateTime})
    end

  end

  defmodule ReportStatusResponse do

    @enforce_keys [:task_id, :status, :stats, :created_at]
    defstruct [task_id: nil, status: nil, stats: nil, logs: [], created_at: nil, updated_at: nil]

    @type t :: %ReportStatusResponse{task_id: String.t(), status: DbProtocol.ReportStatus.t(), stats: JunipeerProtocol.ReportProcessingStats.t(), logs: [JunipeerProtocol.ReportLogEntry.t()], created_at: CommonProtocol.date_time(), updated_at: CommonProtocol.date_time() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      task_id = Igor.Json.parse_field!(json, "task_id", :string)
      status = Igor.Json.parse_field!(json, "status", {:custom, DbProtocol.ReportStatus})
      stats = Igor.Json.parse_field!(json, "stats", {:custom, JunipeerProtocol.ReportProcessingStats})
      logs = Igor.Json.parse_field!(json, "logs", {:list, {:custom, JunipeerProtocol.ReportLogEntry}}, [])
      created_at = Igor.Json.parse_field!(json, "created_at", {:custom, Util.DateTime})
      updated_at = Igor.Json.parse_field!(json, "updated_at", {:custom, Util.DateTime}, nil)
      %ReportStatusResponse{
        task_id: task_id,
        status: status,
        stats: stats,
        logs: logs,
        created_at: created_at,
        updated_at: updated_at
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        task_id: task_id,
        status: status,
        stats: stats,
        logs: logs,
        created_at: created_at,
        updated_at: updated_at
      } = args
      %{}
        |> Igor.Json.pack_field("task_id", task_id, :string)
        |> Igor.Json.pack_field("status", status, {:custom, DbProtocol.ReportStatus})
        |> Igor.Json.pack_field("stats", stats, {:custom, JunipeerProtocol.ReportProcessingStats})
        |> Igor.Json.pack_field("logs", logs, {:list, {:custom, JunipeerProtocol.ReportLogEntry}})
        |> Igor.Json.pack_field("created_at", created_at, {:custom, Util.DateTime})
        |> Igor.Json.pack_field("updated_at", updated_at, {:custom, Util.DateTime})
    end

  end

  defmodule JunipeerApi do

    @spec submit_visma_report(JunipeerProtocol.ReportEnvelope.t(), String.t()) :: JunipeerProtocol.SubmitReportResponse.t()
    def submit_visma_report(request_content, authorization) do
      request_headers = [{"content-type", "application/json"}, {"authorization", authorization}]
      request_body = request_content
        |> Igor.Json.pack_value({:custom, JunipeerProtocol.ReportEnvelope})
        |> Igor.Json.encode!
      url = "#{Application.get_env(:hermes, :junipeer)[:url]}/v1/time-report"
      case HTTPoison.post(url, request_body, request_headers, []) do
        {:ok, %HTTPoison.Response{status_code: 201, body: body}} ->
          body
            |> Igor.Json.decode!()
            |> Igor.Json.parse_value!({:custom, JunipeerProtocol.SubmitReportResponse})
        {:ok, %HTTPoison.Response{status_code: 400, body: body}} ->
          body
            |> Igor.Json.decode!()
            |> Igor.Json.parse_value!({:custom, JunipeerProtocol.JunipeerError})
        {:ok, %HTTPoison.Response{status_code: 401, body: body}} ->
          body
            |> Igor.Json.decode!()
            |> Igor.Json.parse_value!({:custom, JunipeerProtocol.JunipeerError})
        {:ok, %HTTPoison.Response{status_code: 404, body: body}} ->
          body
            |> Igor.Json.decode!()
            |> Igor.Json.parse_value!({:custom, JunipeerProtocol.JunipeerError})
        {:ok, %HTTPoison.Response{status_code: status_code, body: response_body, headers: response_headers}} ->
          raise %Igor.Http.HttpError{status_code: status_code, body: response_body, headers: response_headers}
        {:error, %HTTPoison.Error{reason: _} = e} ->
          raise e
      end
    end

    @spec get_visma_report_status(String.t(), String.t()) :: JunipeerProtocol.ReportStatusResponse.t()
    def get_visma_report_status(task_id, authorization) do
      request_headers = [{"authorization", authorization}]
      url = "#{Application.get_env(:hermes, :junipeer)[:url]}/v1/tasks/#{task_id}"
      case HTTPoison.get(url, request_headers, []) do
        {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->
          body
            |> Igor.Json.decode!()
            |> Igor.Json.parse_value!({:custom, JunipeerProtocol.ReportStatusResponse})
        {:ok, %HTTPoison.Response{status_code: 400, body: body}} ->
          body
            |> Igor.Json.decode!()
            |> Igor.Json.parse_value!({:custom, JunipeerProtocol.JunipeerError})
        {:ok, %HTTPoison.Response{status_code: 401, body: body}} ->
          body
            |> Igor.Json.decode!()
            |> Igor.Json.parse_value!({:custom, JunipeerProtocol.JunipeerError})
        {:ok, %HTTPoison.Response{status_code: 404, body: body}} ->
          body
            |> Igor.Json.decode!()
            |> Igor.Json.parse_value!({:custom, JunipeerProtocol.JunipeerError})
        {:ok, %HTTPoison.Response{status_code: status_code, body: response_body, headers: response_headers}} ->
          raise %Igor.Http.HttpError{status_code: status_code, body: response_body, headers: response_headers}
        {:error, %HTTPoison.Error{reason: _} = e} ->
          raise e
      end
    end

  end

end
