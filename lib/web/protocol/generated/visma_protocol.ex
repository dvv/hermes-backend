# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule VismaProtocol do

  defmodule VismaSummaryEntry do

    @enforce_keys [:project_id, :project_task, :invoiceable]
    defstruct [project_id: nil, project_task: nil, invoiceable: nil, mon: nil, tue: nil, wed: nil, thu: nil, fri: nil, sat: nil, sun: nil]

    @type t :: %VismaSummaryEntry{project_id: String.t(), project_task: String.t(), invoiceable: boolean, mon: integer | nil, tue: integer | nil, wed: integer | nil, thu: integer | nil, fri: integer | nil, sat: integer | nil, sun: integer | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      project_id = Igor.Json.parse_field!(json, "projectId", :string)
      project_task = Igor.Json.parse_field!(json, "projectTask", :string)
      invoiceable = Igor.Json.parse_field!(json, "invoiceable", :boolean)
      mon = Igor.Json.parse_field!(json, "mon", :int, nil)
      tue = Igor.Json.parse_field!(json, "tue", :int, nil)
      wed = Igor.Json.parse_field!(json, "wed", :int, nil)
      thu = Igor.Json.parse_field!(json, "thu", :int, nil)
      fri = Igor.Json.parse_field!(json, "fri", :int, nil)
      sat = Igor.Json.parse_field!(json, "sat", :int, nil)
      sun = Igor.Json.parse_field!(json, "sun", :int, nil)
      %VismaSummaryEntry{
        project_id: project_id,
        project_task: project_task,
        invoiceable: invoiceable,
        mon: mon,
        tue: tue,
        wed: wed,
        thu: thu,
        fri: fri,
        sat: sat,
        sun: sun
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        project_id: project_id,
        project_task: project_task,
        invoiceable: invoiceable,
        mon: mon,
        tue: tue,
        wed: wed,
        thu: thu,
        fri: fri,
        sat: sat,
        sun: sun
      } = args
      %{}
        |> Igor.Json.pack_field("projectId", project_id, :string)
        |> Igor.Json.pack_field("projectTask", project_task, :string)
        |> Igor.Json.pack_field("invoiceable", invoiceable, :boolean)
        |> Igor.Json.pack_field("mon", mon, :int)
        |> Igor.Json.pack_field("tue", tue, :int)
        |> Igor.Json.pack_field("wed", wed, :int)
        |> Igor.Json.pack_field("thu", thu, :int)
        |> Igor.Json.pack_field("fri", fri, :int)
        |> Igor.Json.pack_field("sat", sat, :int)
        |> Igor.Json.pack_field("sun", sun, :int)
    end

  end

  defmodule VismaWeekEntry do

    @enforce_keys [:year, :week, :employee_id, :internal_ref_nr, :summary]
    defstruct [year: nil, week: nil, employee_id: nil, internal_ref_nr: nil, summary: nil]

    @type t :: %VismaWeekEntry{year: integer, week: integer, employee_id: String.t(), internal_ref_nr: String.t(), summary: [VismaProtocol.VismaSummaryEntry.t()]}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      year = Igor.Json.parse_field!(json, "year", :int)
      week = Igor.Json.parse_field!(json, "week", :int)
      employee_id = Igor.Json.parse_field!(json, "employeeId", :string)
      internal_ref_nr = Igor.Json.parse_field!(json, "internalRefNr", :string)
      summary = Igor.Json.parse_field!(json, "summary", {:list, {:custom, VismaProtocol.VismaSummaryEntry}})
      %VismaWeekEntry{
        year: year,
        week: week,
        employee_id: employee_id,
        internal_ref_nr: internal_ref_nr,
        summary: summary
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        year: year,
        week: week,
        employee_id: employee_id,
        internal_ref_nr: internal_ref_nr,
        summary: summary
      } = args
      %{
        "year" => Igor.Json.pack_value(year, :int),
        "week" => Igor.Json.pack_value(week, :int),
        "employeeId" => Igor.Json.pack_value(employee_id, :string),
        "internalRefNr" => Igor.Json.pack_value(internal_ref_nr, :string),
        "summary" => Igor.Json.pack_value(summary, {:list, {:custom, VismaProtocol.VismaSummaryEntry}})
      }
    end

  end

  defmodule ExcelEmployeeEntry do

    @enforce_keys [:uid, :name, :time_offs]
    defstruct [uid: nil, name: nil, time_offs: nil]

    @type t :: %ExcelEmployeeEntry{uid: integer, name: String.t(), time_offs: %{integer => integer}}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      uid = Igor.Json.parse_field!(json, "uid", :long)
      name = Igor.Json.parse_field!(json, "name", :string)
      time_offs = Igor.Json.parse_field!(json, "time_offs", {:map, :int, :int})
      %ExcelEmployeeEntry{uid: uid, name: name, time_offs: time_offs}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{uid: uid, name: name, time_offs: time_offs} = args
      %{
        "uid" => Igor.Json.pack_value(uid, :long),
        "name" => Igor.Json.pack_value(name, :string),
        "time_offs" => Igor.Json.pack_value(time_offs, {:map, :int, :int})
      }
    end

  end

  defmodule ExcelTimeOffReport do

    @enforce_keys [:office_name, :date_from, :date_to, :items]
    defstruct [office_name: nil, date_from: nil, date_to: nil, items: nil]

    @type t :: %ExcelTimeOffReport{office_name: String.t(), date_from: CommonProtocol.date(), date_to: CommonProtocol.date(), items: [VismaProtocol.ExcelEmployeeEntry.t()]}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      office_name = Igor.Json.parse_field!(json, "officeName", :string)
      date_from = Igor.Json.parse_field!(json, "dateFrom", {:custom, Util.Date})
      date_to = Igor.Json.parse_field!(json, "dateTo", {:custom, Util.Date})
      items = Igor.Json.parse_field!(json, "items", {:list, {:custom, VismaProtocol.ExcelEmployeeEntry}})
      %ExcelTimeOffReport{
        office_name: office_name,
        date_from: date_from,
        date_to: date_to,
        items: items
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        office_name: office_name,
        date_from: date_from,
        date_to: date_to,
        items: items
      } = args
      %{
        "officeName" => Igor.Json.pack_value(office_name, :string),
        "dateFrom" => Util.Date.to_json!(date_from),
        "dateTo" => Util.Date.to_json!(date_to),
        "items" => Igor.Json.pack_value(items, {:list, {:custom, VismaProtocol.ExcelEmployeeEntry}})
      }
    end

  end

  defmodule VismaRoleReportEmployee do

    @enforce_keys [:id, :name, :role_title]
    defstruct [id: nil, name: nil, role_title: nil]

    @type t :: %VismaRoleReportEmployee{id: integer, name: String.t(), role_title: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      id = Igor.Json.parse_field!(json, "id", :long)
      name = Igor.Json.parse_field!(json, "name", :string)
      role_title = Igor.Json.parse_field!(json, "role_title", :string)
      %VismaRoleReportEmployee{id: id, name: name, role_title: role_title}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{id: id, name: name, role_title: role_title} = args
      %{
        "id" => Igor.Json.pack_value(id, :long),
        "name" => Igor.Json.pack_value(name, :string),
        "role_title" => Igor.Json.pack_value(role_title, :string)
      }
    end

  end

  defmodule VismaRoleReportRole do

    @enforce_keys [:id, :title, :visma_code, :employee_count, :work_hours, :work_hours_by_project, :absence_hours]
    defstruct [id: nil, title: nil, visma_code: nil, employee_count: nil, work_hours: nil, work_hours_by_project: nil, absence_hours: nil]

    @type t :: %VismaRoleReportRole{id: integer, title: String.t(), visma_code: String.t(), employee_count: non_neg_integer, work_hours: non_neg_integer, work_hours_by_project: %{String.t() => non_neg_integer}, absence_hours: non_neg_integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      id = Igor.Json.parse_field!(json, "id", :long)
      title = Igor.Json.parse_field!(json, "title", :string)
      visma_code = Igor.Json.parse_field!(json, "visma_code", :string)
      employee_count = Igor.Json.parse_field!(json, "employee_count", :uint)
      work_hours = Igor.Json.parse_field!(json, "work_hours", :uint)
      work_hours_by_project = Igor.Json.parse_field!(json, "work_hours_by_project", {:map, :string, :uint})
      absence_hours = Igor.Json.parse_field!(json, "absence_hours", :uint)
      %VismaRoleReportRole{
        id: id,
        title: title,
        visma_code: visma_code,
        employee_count: employee_count,
        work_hours: work_hours,
        work_hours_by_project: work_hours_by_project,
        absence_hours: absence_hours
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        id: id,
        title: title,
        visma_code: visma_code,
        employee_count: employee_count,
        work_hours: work_hours,
        work_hours_by_project: work_hours_by_project,
        absence_hours: absence_hours
      } = args
      %{
        "id" => Igor.Json.pack_value(id, :long),
        "title" => Igor.Json.pack_value(title, :string),
        "visma_code" => Igor.Json.pack_value(visma_code, :string),
        "employee_count" => Igor.Json.pack_value(employee_count, :uint),
        "work_hours" => Igor.Json.pack_value(work_hours, :uint),
        "work_hours_by_project" => Igor.Json.pack_value(work_hours_by_project, {:map, :string, :uint}),
        "absence_hours" => Igor.Json.pack_value(absence_hours, :uint)
      }
    end

  end

  defmodule VismaRoleReport do

    @enforce_keys [:office_id, :office_name, :year, :month, :total_work_hours, :total_absence_hours]
    defstruct [office_id: nil, office_name: nil, year: nil, month: nil, included_employees: [], excluded_employees: [], roles: [], total_work_hours: nil, total_absence_hours: nil]

    @type t :: %VismaRoleReport{office_id: integer, office_name: String.t(), year: integer, month: integer, included_employees: [VismaProtocol.VismaRoleReportEmployee.t()], excluded_employees: [VismaProtocol.VismaRoleReportEmployee.t()], roles: [VismaProtocol.VismaRoleReportRole.t()], total_work_hours: non_neg_integer, total_absence_hours: non_neg_integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      office_id = Igor.Json.parse_field!(json, "office_id", :long)
      office_name = Igor.Json.parse_field!(json, "office_name", :string)
      year = Igor.Json.parse_field!(json, "year", :int)
      month = Igor.Json.parse_field!(json, "month", :int)
      included_employees = Igor.Json.parse_field!(json, "included_employees", {:list, {:custom, VismaProtocol.VismaRoleReportEmployee}}, [])
      excluded_employees = Igor.Json.parse_field!(json, "excluded_employees", {:list, {:custom, VismaProtocol.VismaRoleReportEmployee}}, [])
      roles = Igor.Json.parse_field!(json, "roles", {:list, {:custom, VismaProtocol.VismaRoleReportRole}}, [])
      total_work_hours = Igor.Json.parse_field!(json, "total_work_hours", :uint)
      total_absence_hours = Igor.Json.parse_field!(json, "total_absence_hours", :uint)
      %VismaRoleReport{
        office_id: office_id,
        office_name: office_name,
        year: year,
        month: month,
        included_employees: included_employees,
        excluded_employees: excluded_employees,
        roles: roles,
        total_work_hours: total_work_hours,
        total_absence_hours: total_absence_hours
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        office_id: office_id,
        office_name: office_name,
        year: year,
        month: month,
        included_employees: included_employees,
        excluded_employees: excluded_employees,
        roles: roles,
        total_work_hours: total_work_hours,
        total_absence_hours: total_absence_hours
      } = args
      %{
        "office_id" => Igor.Json.pack_value(office_id, :long),
        "office_name" => Igor.Json.pack_value(office_name, :string),
        "year" => Igor.Json.pack_value(year, :int),
        "month" => Igor.Json.pack_value(month, :int),
        "included_employees" => Igor.Json.pack_value(included_employees, {:list, {:custom, VismaProtocol.VismaRoleReportEmployee}}),
        "excluded_employees" => Igor.Json.pack_value(excluded_employees, {:list, {:custom, VismaProtocol.VismaRoleReportEmployee}}),
        "roles" => Igor.Json.pack_value(roles, {:list, {:custom, VismaProtocol.VismaRoleReportRole}}),
        "total_work_hours" => Igor.Json.pack_value(total_work_hours, :uint),
        "total_absence_hours" => Igor.Json.pack_value(total_absence_hours, :uint)
      }
    end

  end

end
