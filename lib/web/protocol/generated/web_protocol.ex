# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule WebProtocol do

  defmodule PersonnelRights do

    @moduledoc """
    Access control list record
    """
    defstruct [can_login: false, can_update_personnel: false, can_allocate_employee: false, can_deallocate_employee: false, can_link_project: false, can_create_office: false, can_update_office: false, can_delete_office: false, can_get_projects: false, can_get_project: false, can_create_project: false, can_update_project: false, can_delete_project: false, can_get_visma_report: false, can_create_visma_report: false, can_update_visma_report: false, can_get_roles: false, can_get_role: false, can_create_role: false, can_update_role: false, can_delete_role: false, can_modify_role_for_office: false, can_get_teams: false, can_get_team: false, can_create_team: false, can_update_team: false, can_delete_team: false, can_add_team_members: false, can_remove_team_members: false, can_set_team_manager: false, can_get_highlights: false, can_get_highlight: false, can_create_highlight: false, can_update_highlight: false, can_delete_highlight: false, can_assign_highlights: false, can_get_timesheet: false, can_protect_timesheet: false, can_unprotect_timesheet: false, can_regenerate_timesheet: false, can_sync_bamboo: false, can_sync_ldap: false]

    @type t :: %PersonnelRights{can_login: boolean | nil, can_update_personnel: boolean | nil, can_allocate_employee: boolean | nil, can_deallocate_employee: boolean | nil, can_link_project: boolean | nil, can_create_office: boolean | nil, can_update_office: boolean | nil, can_delete_office: boolean | nil, can_get_projects: boolean | nil, can_get_project: boolean | nil, can_create_project: boolean | nil, can_update_project: boolean | nil, can_delete_project: boolean | nil, can_get_visma_report: boolean | nil, can_create_visma_report: boolean | nil, can_update_visma_report: boolean | nil, can_get_roles: boolean | nil, can_get_role: boolean | nil, can_create_role: boolean | nil, can_update_role: boolean | nil, can_delete_role: boolean | nil, can_modify_role_for_office: boolean | nil, can_get_teams: boolean | nil, can_get_team: boolean | nil, can_create_team: boolean | nil, can_update_team: boolean | nil, can_delete_team: boolean | nil, can_add_team_members: boolean | nil, can_remove_team_members: boolean | nil, can_set_team_manager: boolean | nil, can_get_highlights: boolean | nil, can_get_highlight: boolean | nil, can_create_highlight: boolean | nil, can_update_highlight: boolean | nil, can_delete_highlight: boolean | nil, can_assign_highlights: boolean | nil, can_get_timesheet: boolean | nil, can_protect_timesheet: boolean | nil, can_unprotect_timesheet: boolean | nil, can_regenerate_timesheet: boolean | nil, can_sync_bamboo: boolean | nil, can_sync_ldap: boolean | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      can_login = Igor.Json.parse_field!(json, "can_login", :boolean, false)
      can_update_personnel = Igor.Json.parse_field!(json, "can_update_personnel", :boolean, false)
      can_allocate_employee = Igor.Json.parse_field!(json, "can_allocate_employee", :boolean, false)
      can_deallocate_employee = Igor.Json.parse_field!(json, "can_deallocate_employee", :boolean, false)
      can_link_project = Igor.Json.parse_field!(json, "can_link_project", :boolean, false)
      can_create_office = Igor.Json.parse_field!(json, "can_create_office", :boolean, false)
      can_update_office = Igor.Json.parse_field!(json, "can_update_office", :boolean, false)
      can_delete_office = Igor.Json.parse_field!(json, "can_delete_office", :boolean, false)
      can_get_projects = Igor.Json.parse_field!(json, "can_get_projects", :boolean, false)
      can_get_project = Igor.Json.parse_field!(json, "can_get_project", :boolean, false)
      can_create_project = Igor.Json.parse_field!(json, "can_create_project", :boolean, false)
      can_update_project = Igor.Json.parse_field!(json, "can_update_project", :boolean, false)
      can_delete_project = Igor.Json.parse_field!(json, "can_delete_project", :boolean, false)
      can_get_visma_report = Igor.Json.parse_field!(json, "can_get_visma_report", :boolean, false)
      can_create_visma_report = Igor.Json.parse_field!(json, "can_create_visma_report", :boolean, false)
      can_update_visma_report = Igor.Json.parse_field!(json, "can_update_visma_report", :boolean, false)
      can_get_roles = Igor.Json.parse_field!(json, "can_get_roles", :boolean, false)
      can_get_role = Igor.Json.parse_field!(json, "can_get_role", :boolean, false)
      can_create_role = Igor.Json.parse_field!(json, "can_create_role", :boolean, false)
      can_update_role = Igor.Json.parse_field!(json, "can_update_role", :boolean, false)
      can_delete_role = Igor.Json.parse_field!(json, "can_delete_role", :boolean, false)
      can_modify_role_for_office = Igor.Json.parse_field!(json, "can_modify_role_for_office", :boolean, false)
      can_get_teams = Igor.Json.parse_field!(json, "can_get_teams", :boolean, false)
      can_get_team = Igor.Json.parse_field!(json, "can_get_team", :boolean, false)
      can_create_team = Igor.Json.parse_field!(json, "can_create_team", :boolean, false)
      can_update_team = Igor.Json.parse_field!(json, "can_update_team", :boolean, false)
      can_delete_team = Igor.Json.parse_field!(json, "can_delete_team", :boolean, false)
      can_add_team_members = Igor.Json.parse_field!(json, "can_add_team_members", :boolean, false)
      can_remove_team_members = Igor.Json.parse_field!(json, "can_remove_team_members", :boolean, false)
      can_set_team_manager = Igor.Json.parse_field!(json, "can_set_team_manager", :boolean, false)
      can_get_highlights = Igor.Json.parse_field!(json, "can_get_highlights", :boolean, false)
      can_get_highlight = Igor.Json.parse_field!(json, "can_get_highlight", :boolean, false)
      can_create_highlight = Igor.Json.parse_field!(json, "can_create_highlight", :boolean, false)
      can_update_highlight = Igor.Json.parse_field!(json, "can_update_highlight", :boolean, false)
      can_delete_highlight = Igor.Json.parse_field!(json, "can_delete_highlight", :boolean, false)
      can_assign_highlights = Igor.Json.parse_field!(json, "can_assign_highlights", :boolean, false)
      can_get_timesheet = Igor.Json.parse_field!(json, "can_get_timesheet", :boolean, false)
      can_protect_timesheet = Igor.Json.parse_field!(json, "can_protect_timesheet", :boolean, false)
      can_unprotect_timesheet = Igor.Json.parse_field!(json, "can_unprotect_timesheet", :boolean, false)
      can_regenerate_timesheet = Igor.Json.parse_field!(json, "can_regenerate_timesheet", :boolean, false)
      can_sync_bamboo = Igor.Json.parse_field!(json, "can_sync_bamboo", :boolean, false)
      can_sync_ldap = Igor.Json.parse_field!(json, "can_sync_ldap", :boolean, false)
      %PersonnelRights{
        can_login: can_login,
        can_update_personnel: can_update_personnel,
        can_allocate_employee: can_allocate_employee,
        can_deallocate_employee: can_deallocate_employee,
        can_link_project: can_link_project,
        can_create_office: can_create_office,
        can_update_office: can_update_office,
        can_delete_office: can_delete_office,
        can_get_projects: can_get_projects,
        can_get_project: can_get_project,
        can_create_project: can_create_project,
        can_update_project: can_update_project,
        can_delete_project: can_delete_project,
        can_get_visma_report: can_get_visma_report,
        can_create_visma_report: can_create_visma_report,
        can_update_visma_report: can_update_visma_report,
        can_get_roles: can_get_roles,
        can_get_role: can_get_role,
        can_create_role: can_create_role,
        can_update_role: can_update_role,
        can_delete_role: can_delete_role,
        can_modify_role_for_office: can_modify_role_for_office,
        can_get_teams: can_get_teams,
        can_get_team: can_get_team,
        can_create_team: can_create_team,
        can_update_team: can_update_team,
        can_delete_team: can_delete_team,
        can_add_team_members: can_add_team_members,
        can_remove_team_members: can_remove_team_members,
        can_set_team_manager: can_set_team_manager,
        can_get_highlights: can_get_highlights,
        can_get_highlight: can_get_highlight,
        can_create_highlight: can_create_highlight,
        can_update_highlight: can_update_highlight,
        can_delete_highlight: can_delete_highlight,
        can_assign_highlights: can_assign_highlights,
        can_get_timesheet: can_get_timesheet,
        can_protect_timesheet: can_protect_timesheet,
        can_unprotect_timesheet: can_unprotect_timesheet,
        can_regenerate_timesheet: can_regenerate_timesheet,
        can_sync_bamboo: can_sync_bamboo,
        can_sync_ldap: can_sync_ldap
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        can_login: can_login,
        can_update_personnel: can_update_personnel,
        can_allocate_employee: can_allocate_employee,
        can_deallocate_employee: can_deallocate_employee,
        can_link_project: can_link_project,
        can_create_office: can_create_office,
        can_update_office: can_update_office,
        can_delete_office: can_delete_office,
        can_get_projects: can_get_projects,
        can_get_project: can_get_project,
        can_create_project: can_create_project,
        can_update_project: can_update_project,
        can_delete_project: can_delete_project,
        can_get_visma_report: can_get_visma_report,
        can_create_visma_report: can_create_visma_report,
        can_update_visma_report: can_update_visma_report,
        can_get_roles: can_get_roles,
        can_get_role: can_get_role,
        can_create_role: can_create_role,
        can_update_role: can_update_role,
        can_delete_role: can_delete_role,
        can_modify_role_for_office: can_modify_role_for_office,
        can_get_teams: can_get_teams,
        can_get_team: can_get_team,
        can_create_team: can_create_team,
        can_update_team: can_update_team,
        can_delete_team: can_delete_team,
        can_add_team_members: can_add_team_members,
        can_remove_team_members: can_remove_team_members,
        can_set_team_manager: can_set_team_manager,
        can_get_highlights: can_get_highlights,
        can_get_highlight: can_get_highlight,
        can_create_highlight: can_create_highlight,
        can_update_highlight: can_update_highlight,
        can_delete_highlight: can_delete_highlight,
        can_assign_highlights: can_assign_highlights,
        can_get_timesheet: can_get_timesheet,
        can_protect_timesheet: can_protect_timesheet,
        can_unprotect_timesheet: can_unprotect_timesheet,
        can_regenerate_timesheet: can_regenerate_timesheet,
        can_sync_bamboo: can_sync_bamboo,
        can_sync_ldap: can_sync_ldap
      } = args
      %{}
        |> Igor.Json.pack_field("can_login", can_login, :boolean)
        |> Igor.Json.pack_field("can_update_personnel", can_update_personnel, :boolean)
        |> Igor.Json.pack_field("can_allocate_employee", can_allocate_employee, :boolean)
        |> Igor.Json.pack_field("can_deallocate_employee", can_deallocate_employee, :boolean)
        |> Igor.Json.pack_field("can_link_project", can_link_project, :boolean)
        |> Igor.Json.pack_field("can_create_office", can_create_office, :boolean)
        |> Igor.Json.pack_field("can_update_office", can_update_office, :boolean)
        |> Igor.Json.pack_field("can_delete_office", can_delete_office, :boolean)
        |> Igor.Json.pack_field("can_get_projects", can_get_projects, :boolean)
        |> Igor.Json.pack_field("can_get_project", can_get_project, :boolean)
        |> Igor.Json.pack_field("can_create_project", can_create_project, :boolean)
        |> Igor.Json.pack_field("can_update_project", can_update_project, :boolean)
        |> Igor.Json.pack_field("can_delete_project", can_delete_project, :boolean)
        |> Igor.Json.pack_field("can_get_visma_report", can_get_visma_report, :boolean)
        |> Igor.Json.pack_field("can_create_visma_report", can_create_visma_report, :boolean)
        |> Igor.Json.pack_field("can_update_visma_report", can_update_visma_report, :boolean)
        |> Igor.Json.pack_field("can_get_roles", can_get_roles, :boolean)
        |> Igor.Json.pack_field("can_get_role", can_get_role, :boolean)
        |> Igor.Json.pack_field("can_create_role", can_create_role, :boolean)
        |> Igor.Json.pack_field("can_update_role", can_update_role, :boolean)
        |> Igor.Json.pack_field("can_delete_role", can_delete_role, :boolean)
        |> Igor.Json.pack_field("can_modify_role_for_office", can_modify_role_for_office, :boolean)
        |> Igor.Json.pack_field("can_get_teams", can_get_teams, :boolean)
        |> Igor.Json.pack_field("can_get_team", can_get_team, :boolean)
        |> Igor.Json.pack_field("can_create_team", can_create_team, :boolean)
        |> Igor.Json.pack_field("can_update_team", can_update_team, :boolean)
        |> Igor.Json.pack_field("can_delete_team", can_delete_team, :boolean)
        |> Igor.Json.pack_field("can_add_team_members", can_add_team_members, :boolean)
        |> Igor.Json.pack_field("can_remove_team_members", can_remove_team_members, :boolean)
        |> Igor.Json.pack_field("can_set_team_manager", can_set_team_manager, :boolean)
        |> Igor.Json.pack_field("can_get_highlights", can_get_highlights, :boolean)
        |> Igor.Json.pack_field("can_get_highlight", can_get_highlight, :boolean)
        |> Igor.Json.pack_field("can_create_highlight", can_create_highlight, :boolean)
        |> Igor.Json.pack_field("can_update_highlight", can_update_highlight, :boolean)
        |> Igor.Json.pack_field("can_delete_highlight", can_delete_highlight, :boolean)
        |> Igor.Json.pack_field("can_assign_highlights", can_assign_highlights, :boolean)
        |> Igor.Json.pack_field("can_get_timesheet", can_get_timesheet, :boolean)
        |> Igor.Json.pack_field("can_protect_timesheet", can_protect_timesheet, :boolean)
        |> Igor.Json.pack_field("can_unprotect_timesheet", can_unprotect_timesheet, :boolean)
        |> Igor.Json.pack_field("can_regenerate_timesheet", can_regenerate_timesheet, :boolean)
        |> Igor.Json.pack_field("can_sync_bamboo", can_sync_bamboo, :boolean)
        |> Igor.Json.pack_field("can_sync_ldap", can_sync_ldap, :boolean)
    end

  end

  defmodule PersonnelStatusResponse do

    @enforce_keys [:logged_in]
    defstruct [logged_in: nil, user_id: nil, email: nil, username: nil]

    @type t :: %PersonnelStatusResponse{logged_in: boolean, user_id: integer | nil, email: String.t() | nil, username: String.t() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      logged_in = Igor.Json.parse_field!(json, "logged_in", :boolean)
      user_id = Igor.Json.parse_field!(json, "user_id", :long, nil)
      email = Igor.Json.parse_field!(json, "email", :string, nil)
      username = Igor.Json.parse_field!(json, "username", :string, nil)
      %PersonnelStatusResponse{
        logged_in: logged_in,
        user_id: user_id,
        email: email,
        username: username
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        logged_in: logged_in,
        user_id: user_id,
        email: email,
        username: username
      } = args
      %{}
        |> Igor.Json.pack_field("logged_in", logged_in, :boolean)
        |> Igor.Json.pack_field("user_id", user_id, :long)
        |> Igor.Json.pack_field("email", email, :string)
        |> Igor.Json.pack_field("username", username, :string)
    end

  end

  defmodule PersonnelLoginRequest do

    @enforce_keys [:username, :password]
    defstruct [username: nil, password: nil]

    @type t :: %PersonnelLoginRequest{username: String.t(), password: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      username = Igor.Json.parse_field!(json, "username", :string)
      password = Igor.Json.parse_field!(json, "password", :string)
      %PersonnelLoginRequest{username: username, password: password}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{username: username, password: password} = args
      %{
        "username" => Igor.Json.pack_value(username, :string),
        "password" => Igor.Json.pack_value(password, :string)
      }
    end

  end

  defmodule PersonnelLoginError do

    @type t ::
      :invalid_username #
    | :invalid_password #
    | :failure #
    | :already_logged_in #
    | :account_not_exists #
    | :wrong_password #
    | :account_is_blocked #
    | :account_is_deleted #
    | :forbidden #

    defguard is_personnel_login_error(value) when value === :invalid_username or value === :invalid_password or value === :failure or value === :already_logged_in or value === :account_not_exists or value === :wrong_password or value === :account_is_blocked or value === :account_is_deleted or value === :forbidden

    @spec from_string!(String.t()) :: t()
    def from_string!("invalid_username"), do: :invalid_username
    def from_string!("invalid_password"), do: :invalid_password
    def from_string!("failure"), do: :failure
    def from_string!("already_logged_in"), do: :already_logged_in
    def from_string!("account_not_exists"), do: :account_not_exists
    def from_string!("wrong_password"), do: :wrong_password
    def from_string!("account_is_blocked"), do: :account_is_blocked
    def from_string!("account_is_deleted"), do: :account_is_deleted
    def from_string!("forbidden"), do: :forbidden

    @spec to_string!(t()) :: String.t()
    def to_string!(:invalid_username), do: "invalid_username"
    def to_string!(:invalid_password), do: "invalid_password"
    def to_string!(:failure), do: "failure"
    def to_string!(:already_logged_in), do: "already_logged_in"
    def to_string!(:account_not_exists), do: "account_not_exists"
    def to_string!(:wrong_password), do: "wrong_password"
    def to_string!(:account_is_blocked), do: "account_is_blocked"
    def to_string!(:account_is_deleted), do: "account_is_deleted"
    def to_string!(:forbidden), do: "forbidden"

    @spec from_json!(String.t()) :: t()
    def from_json!("invalid_username"), do: :invalid_username
    def from_json!("invalid_password"), do: :invalid_password
    def from_json!("failure"), do: :failure
    def from_json!("already_logged_in"), do: :already_logged_in
    def from_json!("account_not_exists"), do: :account_not_exists
    def from_json!("wrong_password"), do: :wrong_password
    def from_json!("account_is_blocked"), do: :account_is_blocked
    def from_json!("account_is_deleted"), do: :account_is_deleted
    def from_json!("forbidden"), do: :forbidden

    @spec to_json!(t()) :: String.t()
    def to_json!(:invalid_username), do: "invalid_username"
    def to_json!(:invalid_password), do: "invalid_password"
    def to_json!(:failure), do: "failure"
    def to_json!(:already_logged_in), do: "already_logged_in"
    def to_json!(:account_not_exists), do: "account_not_exists"
    def to_json!(:wrong_password), do: "wrong_password"
    def to_json!(:account_is_blocked), do: "account_is_blocked"
    def to_json!(:account_is_deleted), do: "account_is_deleted"
    def to_json!(:forbidden), do: "forbidden"

  end

  defmodule PersonnelLoginResponse do

    @enforce_keys [:result]
    defstruct [result: nil, error: nil, session_id: nil, user_id: nil, email: nil, username: nil]

    @type t :: %PersonnelLoginResponse{result: boolean, error: WebProtocol.PersonnelLoginError.t() | nil, session_id: String.t() | nil, user_id: integer | nil, email: String.t() | nil, username: String.t() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      result = Igor.Json.parse_field!(json, "result", :boolean)
      error = Igor.Json.parse_field!(json, "error", {:custom, WebProtocol.PersonnelLoginError}, nil)
      session_id = Igor.Json.parse_field!(json, "session_id", :string, nil)
      user_id = Igor.Json.parse_field!(json, "user_id", :long, nil)
      email = Igor.Json.parse_field!(json, "email", :string, nil)
      username = Igor.Json.parse_field!(json, "username", :string, nil)
      %PersonnelLoginResponse{
        result: result,
        error: error,
        session_id: session_id,
        user_id: user_id,
        email: email,
        username: username
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        result: result,
        error: error,
        session_id: session_id,
        user_id: user_id,
        email: email,
        username: username
      } = args
      %{}
        |> Igor.Json.pack_field("result", result, :boolean)
        |> Igor.Json.pack_field("error", error, {:custom, WebProtocol.PersonnelLoginError})
        |> Igor.Json.pack_field("session_id", session_id, :string)
        |> Igor.Json.pack_field("user_id", user_id, :long)
        |> Igor.Json.pack_field("email", email, :string)
        |> Igor.Json.pack_field("username", username, :string)
    end

  end

  defmodule UpdatePersonnelAccountRequest do

    @type t :: %{optional(:office_id) => integer, optional(:is_office_manager) => boolean, optional(:role_id) => integer, optional(:hired_at) => CommonProtocol.date_time(), optional(:fired_at) => CommonProtocol.date_time()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      %{}
        |> field_from_json(json, "office_id", {:option, :long}, :office_id)
        |> field_from_json(json, "is_office_manager", {:option, :boolean}, :is_office_manager)
        |> field_from_json(json, "role_id", {:option, :long}, :role_id)
        |> field_from_json(json, "hired_at", {:option, {:custom, Util.DateTime}}, :hired_at)
        |> field_from_json(json, "fired_at", {:option, {:custom, Util.DateTime}}, :fired_at)
    end

    defp field_from_json(map, json, json_key, type, map_key) do
      case Map.fetch(json, json_key) do
        {:ok, value} -> Map.put(map, map_key, Igor.Json.parse_value!(value, type))
        :error -> map
      end
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{}
        |> field_to_json(args, :office_id, {:option, :long}, "office_id")
        |> field_to_json(args, :is_office_manager, {:option, :boolean}, "is_office_manager")
        |> field_to_json(args, :role_id, {:option, :long}, "role_id")
        |> field_to_json(args, :hired_at, {:option, {:custom, Util.DateTime}}, "hired_at")
        |> field_to_json(args, :fired_at, {:option, {:custom, Util.DateTime}}, "fired_at")
    end

    defp field_to_json(json, map, map_key, type, json_key) do
      case Map.fetch(map, map_key) do
        {:ok, value} -> Map.put(json, json_key, Igor.Json.pack_value(value, type))
        :error -> json
      end
    end

  end

  defmodule UpdatePersonnelAccountError do

    @type t ::
      :invalid_office_id #
    | :invalid_is_office_manager #
    | :invalid_role_id #
    | :office_not_exists #
    | :role_not_exists #

    defguard is_update_personnel_account_error(value) when value === :invalid_office_id or value === :invalid_is_office_manager or value === :invalid_role_id or value === :office_not_exists or value === :role_not_exists

    @spec from_string!(String.t()) :: t()
    def from_string!("invalid_office_id"), do: :invalid_office_id
    def from_string!("invalid_is_office_manager"), do: :invalid_is_office_manager
    def from_string!("invalid_role_id"), do: :invalid_role_id
    def from_string!("office_not_exists"), do: :office_not_exists
    def from_string!("role_not_exists"), do: :role_not_exists

    @spec to_string!(t()) :: String.t()
    def to_string!(:invalid_office_id), do: "invalid_office_id"
    def to_string!(:invalid_is_office_manager), do: "invalid_is_office_manager"
    def to_string!(:invalid_role_id), do: "invalid_role_id"
    def to_string!(:office_not_exists), do: "office_not_exists"
    def to_string!(:role_not_exists), do: "role_not_exists"

    @spec from_json!(String.t()) :: t()
    def from_json!("invalid_office_id"), do: :invalid_office_id
    def from_json!("invalid_is_office_manager"), do: :invalid_is_office_manager
    def from_json!("invalid_role_id"), do: :invalid_role_id
    def from_json!("office_not_exists"), do: :office_not_exists
    def from_json!("role_not_exists"), do: :role_not_exists

    @spec to_json!(t()) :: String.t()
    def to_json!(:invalid_office_id), do: "invalid_office_id"
    def to_json!(:invalid_is_office_manager), do: "invalid_is_office_manager"
    def to_json!(:invalid_role_id), do: "invalid_role_id"
    def to_json!(:office_not_exists), do: "office_not_exists"
    def to_json!(:role_not_exists), do: "role_not_exists"

  end

  defmodule PersonnelAccountOrderBy do

    @moduledoc """
    Personnel accounts
    """

    @type t ::
      :id #
    | :username #
    | :name #
    | :email #
    | :office_id #
    | :office_name #
    | :office_country_alpha2 #
    | :office_country_name #
    | :supervisor_id #
    | :supervisor_username #
    | :supervisor_name #
    | :is_blocked #
    | :is_deleted #
    | :created_at #
    | :updated_at #

    defguard is_personnel_account_order_by(value) when value === :id or value === :username or value === :name or value === :email or value === :office_id or value === :office_name or value === :office_country_alpha2 or value === :office_country_name or value === :supervisor_id or value === :supervisor_username or value === :supervisor_name or value === :is_blocked or value === :is_deleted or value === :created_at or value === :updated_at

    @spec from_string!(String.t()) :: t()
    def from_string!("id"), do: :id
    def from_string!("username"), do: :username
    def from_string!("name"), do: :name
    def from_string!("email"), do: :email
    def from_string!("office_id"), do: :office_id
    def from_string!("office_name"), do: :office_name
    def from_string!("office_country_alpha2"), do: :office_country_alpha2
    def from_string!("office_country_name"), do: :office_country_name
    def from_string!("supervisor_id"), do: :supervisor_id
    def from_string!("supervisor_username"), do: :supervisor_username
    def from_string!("supervisor_name"), do: :supervisor_name
    def from_string!("is_blocked"), do: :is_blocked
    def from_string!("is_deleted"), do: :is_deleted
    def from_string!("created_at"), do: :created_at
    def from_string!("updated_at"), do: :updated_at

    @spec to_string!(t()) :: String.t()
    def to_string!(:id), do: "id"
    def to_string!(:username), do: "username"
    def to_string!(:name), do: "name"
    def to_string!(:email), do: "email"
    def to_string!(:office_id), do: "office_id"
    def to_string!(:office_name), do: "office_name"
    def to_string!(:office_country_alpha2), do: "office_country_alpha2"
    def to_string!(:office_country_name), do: "office_country_name"
    def to_string!(:supervisor_id), do: "supervisor_id"
    def to_string!(:supervisor_username), do: "supervisor_username"
    def to_string!(:supervisor_name), do: "supervisor_name"
    def to_string!(:is_blocked), do: "is_blocked"
    def to_string!(:is_deleted), do: "is_deleted"
    def to_string!(:created_at), do: "created_at"
    def to_string!(:updated_at), do: "updated_at"

    @spec from_json!(String.t()) :: t()
    def from_json!("id"), do: :id
    def from_json!("username"), do: :username
    def from_json!("name"), do: :name
    def from_json!("email"), do: :email
    def from_json!("office_id"), do: :office_id
    def from_json!("office_name"), do: :office_name
    def from_json!("office_country_alpha2"), do: :office_country_alpha2
    def from_json!("office_country_name"), do: :office_country_name
    def from_json!("supervisor_id"), do: :supervisor_id
    def from_json!("supervisor_username"), do: :supervisor_username
    def from_json!("supervisor_name"), do: :supervisor_name
    def from_json!("is_blocked"), do: :is_blocked
    def from_json!("is_deleted"), do: :is_deleted
    def from_json!("created_at"), do: :created_at
    def from_json!("updated_at"), do: :updated_at

    @spec to_json!(t()) :: String.t()
    def to_json!(:id), do: "id"
    def to_json!(:username), do: "username"
    def to_json!(:name), do: "name"
    def to_json!(:email), do: "email"
    def to_json!(:office_id), do: "office_id"
    def to_json!(:office_name), do: "office_name"
    def to_json!(:office_country_alpha2), do: "office_country_alpha2"
    def to_json!(:office_country_name), do: "office_country_name"
    def to_json!(:supervisor_id), do: "supervisor_id"
    def to_json!(:supervisor_username), do: "supervisor_username"
    def to_json!(:supervisor_name), do: "supervisor_name"
    def to_json!(:is_blocked), do: "is_blocked"
    def to_json!(:is_deleted), do: "is_deleted"
    def to_json!(:created_at), do: "created_at"
    def to_json!(:updated_at), do: "updated_at"

  end

  defmodule PersonnelAccountRoleOrderBy do

    @moduledoc """
    Personnel account roles
    """

    @type t ::
      :personnel_id #
    | :username #
    | :project_id #
    | :project_name #
    | :user_role #

    defguard is_personnel_account_role_order_by(value) when value === :personnel_id or value === :username or value === :project_id or value === :project_name or value === :user_role

    @spec from_string!(String.t()) :: t()
    def from_string!("personnel_id"), do: :personnel_id
    def from_string!("username"), do: :username
    def from_string!("project_id"), do: :project_id
    def from_string!("project_name"), do: :project_name
    def from_string!("user_role"), do: :user_role

    @spec to_string!(t()) :: String.t()
    def to_string!(:personnel_id), do: "personnel_id"
    def to_string!(:username), do: "username"
    def to_string!(:project_id), do: "project_id"
    def to_string!(:project_name), do: "project_name"
    def to_string!(:user_role), do: "user_role"

    @spec from_json!(String.t()) :: t()
    def from_json!("personnel_id"), do: :personnel_id
    def from_json!("username"), do: :username
    def from_json!("project_id"), do: :project_id
    def from_json!("project_name"), do: :project_name
    def from_json!("user_role"), do: :user_role

    @spec to_json!(t()) :: String.t()
    def to_json!(:personnel_id), do: "personnel_id"
    def to_json!(:username), do: "username"
    def to_json!(:project_id), do: "project_id"
    def to_json!(:project_name), do: "project_name"
    def to_json!(:user_role), do: "user_role"

  end

  defmodule PersonnelGroupOrderBy do

    @moduledoc """
    Personnel groups
    """

    @type t ::
      :id #
    | :name #
    | :is_deleted #
    | :member_count #
    | :created_at #
    | :updated_at #

    defguard is_personnel_group_order_by(value) when value === :id or value === :name or value === :is_deleted or value === :member_count or value === :created_at or value === :updated_at

    @spec from_string!(String.t()) :: t()
    def from_string!("id"), do: :id
    def from_string!("name"), do: :name
    def from_string!("is_deleted"), do: :is_deleted
    def from_string!("member_count"), do: :member_count
    def from_string!("created_at"), do: :created_at
    def from_string!("updated_at"), do: :updated_at

    @spec to_string!(t()) :: String.t()
    def to_string!(:id), do: "id"
    def to_string!(:name), do: "name"
    def to_string!(:is_deleted), do: "is_deleted"
    def to_string!(:member_count), do: "member_count"
    def to_string!(:created_at), do: "created_at"
    def to_string!(:updated_at), do: "updated_at"

    @spec from_json!(String.t()) :: t()
    def from_json!("id"), do: :id
    def from_json!("name"), do: :name
    def from_json!("is_deleted"), do: :is_deleted
    def from_json!("member_count"), do: :member_count
    def from_json!("created_at"), do: :created_at
    def from_json!("updated_at"), do: :updated_at

    @spec to_json!(t()) :: String.t()
    def to_json!(:id), do: "id"
    def to_json!(:name), do: "name"
    def to_json!(:is_deleted), do: "is_deleted"
    def to_json!(:member_count), do: "member_count"
    def to_json!(:created_at), do: "created_at"
    def to_json!(:updated_at), do: "updated_at"

  end

  defmodule PersonnelGroupRoleOrderBy do

    @moduledoc """
    Personnel group roles
    """

    @type t ::
      :group_id #
    | :group_name #
    | :project_id #
    | :project_title #
    | :group_role #

    defguard is_personnel_group_role_order_by(value) when value === :group_id or value === :group_name or value === :project_id or value === :project_title or value === :group_role

    @spec from_string!(String.t()) :: t()
    def from_string!("group_id"), do: :group_id
    def from_string!("group_name"), do: :group_name
    def from_string!("project_id"), do: :project_id
    def from_string!("project_title"), do: :project_title
    def from_string!("group_role"), do: :group_role

    @spec to_string!(t()) :: String.t()
    def to_string!(:group_id), do: "group_id"
    def to_string!(:group_name), do: "group_name"
    def to_string!(:project_id), do: "project_id"
    def to_string!(:project_title), do: "project_title"
    def to_string!(:group_role), do: "group_role"

    @spec from_json!(String.t()) :: t()
    def from_json!("group_id"), do: :group_id
    def from_json!("group_name"), do: :group_name
    def from_json!("project_id"), do: :project_id
    def from_json!("project_title"), do: :project_title
    def from_json!("group_role"), do: :group_role

    @spec to_json!(t()) :: String.t()
    def to_json!(:group_id), do: "group_id"
    def to_json!(:group_name), do: "group_name"
    def to_json!(:project_id), do: "project_id"
    def to_json!(:project_title), do: "project_title"
    def to_json!(:group_role), do: "group_role"

  end

  defmodule AccessRoleUpdateRequest do

    @enforce_keys [:role]
    defstruct [role: nil]

    @type t :: %AccessRoleUpdateRequest{role: DbProtocol.AccessRole.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      role = Igor.Json.parse_field!(json, "role", {:custom, DbProtocol.AccessRole})
      %AccessRoleUpdateRequest{role: role}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{role: role} = args
      %{
        "role" => DbProtocol.AccessRole.to_json!(role)
      }
    end

  end

  defmodule Settings do

    @moduledoc """
    Settings (admin-oriented info)
    """
    @enforce_keys [:personnel_session_duration]
    defstruct [personnel_session_duration: nil]

    @type t :: %Settings{personnel_session_duration: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      personnel_session_duration = Igor.Json.parse_field!(json, "personnel_session_duration", :int)
      %Settings{personnel_session_duration: personnel_session_duration}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{personnel_session_duration: personnel_session_duration} = args
      %{
        "personnel_session_duration" => Igor.Json.pack_value(personnel_session_duration, :int)
      }
    end

  end

  defmodule SettingsUpdateRequest do

    @moduledoc """
    AdminService -> UpdateSettings
    """
    defstruct [personnel_session_duration: nil]

    @type t :: %SettingsUpdateRequest{personnel_session_duration: integer | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      personnel_session_duration = Igor.Json.parse_field!(json, "personnel_session_duration", :int, nil)
      %SettingsUpdateRequest{personnel_session_duration: personnel_session_duration}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{personnel_session_duration: personnel_session_duration} = args
      %{}
        |> Igor.Json.pack_field("personnel_session_duration", personnel_session_duration, :int)
    end

  end

  defmodule EmployeeAlloc do

    @moduledoc """
    Employees
    """
    @enforce_keys [:project_id]
    defstruct [project_id: nil]

    @type t :: %EmployeeAlloc{project_id: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      project_id = Igor.Json.parse_field!(json, "project_id", :long)
      %EmployeeAlloc{project_id: project_id}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{project_id: project_id} = args
      %{
        "project_id" => Igor.Json.pack_value(project_id, :long)
      }
    end

  end

  defmodule EmployeeAllocError do

    @type t ::
      :invalid_project_id #
    | :project_not_exists #

    defguard is_employee_alloc_error(value) when value === :invalid_project_id or value === :project_not_exists

    @spec from_string!(String.t()) :: t()
    def from_string!("invalid_project_id"), do: :invalid_project_id
    def from_string!("project_not_exists"), do: :project_not_exists

    @spec to_string!(t()) :: String.t()
    def to_string!(:invalid_project_id), do: "invalid_project_id"
    def to_string!(:project_not_exists), do: "project_not_exists"

    @spec from_json!(String.t()) :: t()
    def from_json!("invalid_project_id"), do: :invalid_project_id
    def from_json!("project_not_exists"), do: :project_not_exists

    @spec to_json!(t()) :: String.t()
    def to_json!(:invalid_project_id), do: "invalid_project_id"
    def to_json!(:project_not_exists), do: "project_not_exists"

  end

  defmodule CreateOfficeRequest do

    @moduledoc """
    Offices
    """
    @enforce_keys [:name, :country_id]
    defstruct [name: nil, country_id: nil, city: nil, address: nil, postal_code: nil, group_id: nil, visma_country: nil, visma_company_id: nil]

    @type t :: %CreateOfficeRequest{name: String.t(), country_id: integer, city: String.t() | nil, address: String.t() | nil, postal_code: String.t() | nil, group_id: integer | nil, visma_country: String.t() | nil, visma_company_id: String.t() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      name = Igor.Json.parse_field!(json, "name", :string)
      country_id = Igor.Json.parse_field!(json, "country_id", :long)
      city = Igor.Json.parse_field!(json, "city", :string, nil)
      address = Igor.Json.parse_field!(json, "address", :string, nil)
      postal_code = Igor.Json.parse_field!(json, "postal_code", :string, nil)
      group_id = Igor.Json.parse_field!(json, "group_id", :long, nil)
      visma_country = Igor.Json.parse_field!(json, "visma_country", :string, nil)
      visma_company_id = Igor.Json.parse_field!(json, "visma_company_id", :string, nil)
      %CreateOfficeRequest{
        name: name,
        country_id: country_id,
        city: city,
        address: address,
        postal_code: postal_code,
        group_id: group_id,
        visma_country: visma_country,
        visma_company_id: visma_company_id
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        name: name,
        country_id: country_id,
        city: city,
        address: address,
        postal_code: postal_code,
        group_id: group_id,
        visma_country: visma_country,
        visma_company_id: visma_company_id
      } = args
      %{}
        |> Igor.Json.pack_field("name", name, :string)
        |> Igor.Json.pack_field("country_id", country_id, :long)
        |> Igor.Json.pack_field("city", city, :string)
        |> Igor.Json.pack_field("address", address, :string)
        |> Igor.Json.pack_field("postal_code", postal_code, :string)
        |> Igor.Json.pack_field("group_id", group_id, :long)
        |> Igor.Json.pack_field("visma_country", visma_country, :string)
        |> Igor.Json.pack_field("visma_company_id", visma_company_id, :string)
    end

  end

  defmodule UpdateOfficeRequest do

    @type t :: %{optional(:name) => String.t(), optional(:country_id) => integer, optional(:city) => String.t(), optional(:address) => String.t(), optional(:postal_code) => String.t(), optional(:group_id) => integer, optional(:visma_country) => String.t(), optional(:visma_company_id) => String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      %{}
        |> field_from_json(json, "name", :string, :name)
        |> field_from_json(json, "country_id", :long, :country_id)
        |> field_from_json(json, "city", {:option, :string}, :city)
        |> field_from_json(json, "address", {:option, :string}, :address)
        |> field_from_json(json, "postal_code", {:option, :string}, :postal_code)
        |> field_from_json(json, "group_id", {:option, :long}, :group_id)
        |> field_from_json(json, "visma_country", {:option, :string}, :visma_country)
        |> field_from_json(json, "visma_company_id", {:option, :string}, :visma_company_id)
    end

    defp field_from_json(map, json, json_key, type, map_key) do
      case Map.fetch(json, json_key) do
        {:ok, value} -> Map.put(map, map_key, Igor.Json.parse_value!(value, type))
        :error -> map
      end
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{}
        |> field_to_json(args, :name, :string, "name")
        |> field_to_json(args, :country_id, :long, "country_id")
        |> field_to_json(args, :city, {:option, :string}, "city")
        |> field_to_json(args, :address, {:option, :string}, "address")
        |> field_to_json(args, :postal_code, {:option, :string}, "postal_code")
        |> field_to_json(args, :group_id, {:option, :long}, "group_id")
        |> field_to_json(args, :visma_country, {:option, :string}, "visma_country")
        |> field_to_json(args, :visma_company_id, {:option, :string}, "visma_company_id")
    end

    defp field_to_json(json, map, map_key, type, json_key) do
      case Map.fetch(map, map_key) do
        {:ok, value} -> Map.put(json, json_key, Igor.Json.pack_value(value, type))
        :error -> json
      end
    end

  end

  defmodule OfficeManagementError do

    @type t ::
      :invalid_name #
    | :invalid_country_id #
    | :invalid_city #
    | :invalid_address #
    | :invalid_postal_code #
    | :invalid_group_id #
    | :country_not_exists #
    | :group_not_exists #
    | :name_already_exists #

    defguard is_office_management_error(value) when value === :invalid_name or value === :invalid_country_id or value === :invalid_city or value === :invalid_address or value === :invalid_postal_code or value === :invalid_group_id or value === :country_not_exists or value === :group_not_exists or value === :name_already_exists

    @spec from_string!(String.t()) :: t()
    def from_string!("invalid_name"), do: :invalid_name
    def from_string!("invalid_country_id"), do: :invalid_country_id
    def from_string!("invalid_city"), do: :invalid_city
    def from_string!("invalid_address"), do: :invalid_address
    def from_string!("invalid_postal_code"), do: :invalid_postal_code
    def from_string!("invalid_group_id"), do: :invalid_group_id
    def from_string!("country_not_exists"), do: :country_not_exists
    def from_string!("group_not_exists"), do: :group_not_exists
    def from_string!("name_already_exists"), do: :name_already_exists

    @spec to_string!(t()) :: String.t()
    def to_string!(:invalid_name), do: "invalid_name"
    def to_string!(:invalid_country_id), do: "invalid_country_id"
    def to_string!(:invalid_city), do: "invalid_city"
    def to_string!(:invalid_address), do: "invalid_address"
    def to_string!(:invalid_postal_code), do: "invalid_postal_code"
    def to_string!(:invalid_group_id), do: "invalid_group_id"
    def to_string!(:country_not_exists), do: "country_not_exists"
    def to_string!(:group_not_exists), do: "group_not_exists"
    def to_string!(:name_already_exists), do: "name_already_exists"

    @spec from_json!(String.t()) :: t()
    def from_json!("invalid_name"), do: :invalid_name
    def from_json!("invalid_country_id"), do: :invalid_country_id
    def from_json!("invalid_city"), do: :invalid_city
    def from_json!("invalid_address"), do: :invalid_address
    def from_json!("invalid_postal_code"), do: :invalid_postal_code
    def from_json!("invalid_group_id"), do: :invalid_group_id
    def from_json!("country_not_exists"), do: :country_not_exists
    def from_json!("group_not_exists"), do: :group_not_exists
    def from_json!("name_already_exists"), do: :name_already_exists

    @spec to_json!(t()) :: String.t()
    def to_json!(:invalid_name), do: "invalid_name"
    def to_json!(:invalid_country_id), do: "invalid_country_id"
    def to_json!(:invalid_city), do: "invalid_city"
    def to_json!(:invalid_address), do: "invalid_address"
    def to_json!(:invalid_postal_code), do: "invalid_postal_code"
    def to_json!(:invalid_group_id), do: "invalid_group_id"
    def to_json!(:country_not_exists), do: "country_not_exists"
    def to_json!(:group_not_exists), do: "group_not_exists"
    def to_json!(:name_already_exists), do: "name_already_exists"

  end

  defmodule CreateProjectRequest do

    @moduledoc """
    Projects
    """
    @enforce_keys [:title, :key, :leading_office_id, :finance_code, :invoiceable]
    defstruct [title: nil, key: nil, supervisor_id: nil, leading_office_id: nil, color: nil, finance_code: nil, invoiceable: nil, is_archived: false, task_code: nil, started_at: nil, finished_at: nil]

    @type t :: %CreateProjectRequest{title: String.t(), key: String.t(), supervisor_id: integer | nil, leading_office_id: integer, color: String.t() | nil, finance_code: String.t(), invoiceable: boolean, is_archived: boolean, task_code: DbProtocol.TaskKind.t() | nil, started_at: CommonProtocol.date_time() | nil, finished_at: CommonProtocol.date_time() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      title = Igor.Json.parse_field!(json, "title", :string)
      key = Igor.Json.parse_field!(json, "key", :string)
      supervisor_id = Igor.Json.parse_field!(json, "supervisor_id", :long, nil)
      leading_office_id = Igor.Json.parse_field!(json, "leading_office_id", :long)
      color = Igor.Json.parse_field!(json, "color", :string, nil)
      finance_code = Igor.Json.parse_field!(json, "finance_code", :string)
      invoiceable = Igor.Json.parse_field!(json, "invoiceable", :boolean)
      is_archived = Igor.Json.parse_field!(json, "is_archived", :boolean, false)
      task_code = Igor.Json.parse_field!(json, "task_code", {:custom, DbProtocol.TaskKind}, nil)
      started_at = Igor.Json.parse_field!(json, "started_at", {:custom, Util.DateTime}, nil)
      finished_at = Igor.Json.parse_field!(json, "finished_at", {:custom, Util.DateTime}, nil)
      %CreateProjectRequest{
        title: title,
        key: key,
        supervisor_id: supervisor_id,
        leading_office_id: leading_office_id,
        color: color,
        finance_code: finance_code,
        invoiceable: invoiceable,
        is_archived: is_archived,
        task_code: task_code,
        started_at: started_at,
        finished_at: finished_at
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        title: title,
        key: key,
        supervisor_id: supervisor_id,
        leading_office_id: leading_office_id,
        color: color,
        finance_code: finance_code,
        invoiceable: invoiceable,
        is_archived: is_archived,
        task_code: task_code,
        started_at: started_at,
        finished_at: finished_at
      } = args
      %{}
        |> Igor.Json.pack_field("title", title, :string)
        |> Igor.Json.pack_field("key", key, :string)
        |> Igor.Json.pack_field("supervisor_id", supervisor_id, :long)
        |> Igor.Json.pack_field("leading_office_id", leading_office_id, :long)
        |> Igor.Json.pack_field("color", color, :string)
        |> Igor.Json.pack_field("finance_code", finance_code, :string)
        |> Igor.Json.pack_field("invoiceable", invoiceable, :boolean)
        |> Igor.Json.pack_field("is_archived", is_archived, :boolean)
        |> Igor.Json.pack_field("task_code", task_code, {:custom, DbProtocol.TaskKind})
        |> Igor.Json.pack_field("started_at", started_at, {:custom, Util.DateTime})
        |> Igor.Json.pack_field("finished_at", finished_at, {:custom, Util.DateTime})
    end

  end

  defmodule UpdateProjectRequest do

    @type t :: %{optional(:title) => String.t(), optional(:key) => String.t(), optional(:supervisor_id) => integer, optional(:leading_office_id) => integer, optional(:color) => String.t(), optional(:finance_code) => String.t(), optional(:invoiceable) => boolean, optional(:is_archived) => boolean, optional(:task_code) => DbProtocol.TaskKind.t(), optional(:started_at) => CommonProtocol.date_time(), optional(:finished_at) => CommonProtocol.date_time()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      %{}
        |> field_from_json(json, "title", :string, :title)
        |> field_from_json(json, "key", :string, :key)
        |> field_from_json(json, "supervisor_id", {:option, :long}, :supervisor_id)
        |> field_from_json(json, "leading_office_id", :long, :leading_office_id)
        |> field_from_json(json, "color", {:option, :string}, :color)
        |> field_from_json(json, "finance_code", :string, :finance_code)
        |> field_from_json(json, "invoiceable", :boolean, :invoiceable)
        |> field_from_json(json, "is_archived", :boolean, :is_archived)
        |> field_from_json(json, "task_code", {:option, {:custom, DbProtocol.TaskKind}}, :task_code)
        |> field_from_json(json, "started_at", {:option, {:custom, Util.DateTime}}, :started_at)
        |> field_from_json(json, "finished_at", {:option, {:custom, Util.DateTime}}, :finished_at)
    end

    defp field_from_json(map, json, json_key, type, map_key) do
      case Map.fetch(json, json_key) do
        {:ok, value} -> Map.put(map, map_key, Igor.Json.parse_value!(value, type))
        :error -> map
      end
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{}
        |> field_to_json(args, :title, :string, "title")
        |> field_to_json(args, :key, :string, "key")
        |> field_to_json(args, :supervisor_id, {:option, :long}, "supervisor_id")
        |> field_to_json(args, :leading_office_id, :long, "leading_office_id")
        |> field_to_json(args, :color, {:option, :string}, "color")
        |> field_to_json(args, :finance_code, :string, "finance_code")
        |> field_to_json(args, :invoiceable, :boolean, "invoiceable")
        |> field_to_json(args, :is_archived, :boolean, "is_archived")
        |> field_to_json(args, :task_code, {:option, {:custom, DbProtocol.TaskKind}}, "task_code")
        |> field_to_json(args, :started_at, {:option, {:custom, Util.DateTime}}, "started_at")
        |> field_to_json(args, :finished_at, {:option, {:custom, Util.DateTime}}, "finished_at")
    end

    defp field_to_json(json, map, map_key, type, json_key) do
      case Map.fetch(map, map_key) do
        {:ok, value} -> Map.put(json, json_key, Igor.Json.pack_value(value, type))
        :error -> json
      end
    end

  end

  defmodule ProjectError do

    @type t ::
      :invalid_title #
    | :invalid_key #
    | :invalid_supervisor_id #
    | :invalid_leading_office_id #
    | :invalid_color #
    | :invalid_finance_code #
    | :invalid_invoiceable #
    | :invalid_is_archived #
    | :invalid_task_code #
    | :supervisor_not_exists #
    | :leading_office_not_exists #
    | :title_already_exists #
    | :key_already_exists #

    defguard is_project_error(value) when value === :invalid_title or value === :invalid_key or value === :invalid_supervisor_id or value === :invalid_leading_office_id or value === :invalid_color or value === :invalid_finance_code or value === :invalid_invoiceable or value === :invalid_is_archived or value === :invalid_task_code or value === :supervisor_not_exists or value === :leading_office_not_exists or value === :title_already_exists or value === :key_already_exists

    @spec from_string!(String.t()) :: t()
    def from_string!("invalid_title"), do: :invalid_title
    def from_string!("invalid_key"), do: :invalid_key
    def from_string!("invalid_supervisor_id"), do: :invalid_supervisor_id
    def from_string!("invalid_leading_office_id"), do: :invalid_leading_office_id
    def from_string!("invalid_color"), do: :invalid_color
    def from_string!("invalid_finance_code"), do: :invalid_finance_code
    def from_string!("invalid_invoiceable"), do: :invalid_invoiceable
    def from_string!("invalid_is_archived"), do: :invalid_is_archived
    def from_string!("invalid_task_code"), do: :invalid_task_code
    def from_string!("supervisor_not_exists"), do: :supervisor_not_exists
    def from_string!("leading_office_not_exists"), do: :leading_office_not_exists
    def from_string!("title_already_exists"), do: :title_already_exists
    def from_string!("key_already_exists"), do: :key_already_exists

    @spec to_string!(t()) :: String.t()
    def to_string!(:invalid_title), do: "invalid_title"
    def to_string!(:invalid_key), do: "invalid_key"
    def to_string!(:invalid_supervisor_id), do: "invalid_supervisor_id"
    def to_string!(:invalid_leading_office_id), do: "invalid_leading_office_id"
    def to_string!(:invalid_color), do: "invalid_color"
    def to_string!(:invalid_finance_code), do: "invalid_finance_code"
    def to_string!(:invalid_invoiceable), do: "invalid_invoiceable"
    def to_string!(:invalid_is_archived), do: "invalid_is_archived"
    def to_string!(:invalid_task_code), do: "invalid_task_code"
    def to_string!(:supervisor_not_exists), do: "supervisor_not_exists"
    def to_string!(:leading_office_not_exists), do: "leading_office_not_exists"
    def to_string!(:title_already_exists), do: "title_already_exists"
    def to_string!(:key_already_exists), do: "key_already_exists"

    @spec from_json!(String.t()) :: t()
    def from_json!("invalid_title"), do: :invalid_title
    def from_json!("invalid_key"), do: :invalid_key
    def from_json!("invalid_supervisor_id"), do: :invalid_supervisor_id
    def from_json!("invalid_leading_office_id"), do: :invalid_leading_office_id
    def from_json!("invalid_color"), do: :invalid_color
    def from_json!("invalid_finance_code"), do: :invalid_finance_code
    def from_json!("invalid_invoiceable"), do: :invalid_invoiceable
    def from_json!("invalid_is_archived"), do: :invalid_is_archived
    def from_json!("invalid_task_code"), do: :invalid_task_code
    def from_json!("supervisor_not_exists"), do: :supervisor_not_exists
    def from_json!("leading_office_not_exists"), do: :leading_office_not_exists
    def from_json!("title_already_exists"), do: :title_already_exists
    def from_json!("key_already_exists"), do: :key_already_exists

    @spec to_json!(t()) :: String.t()
    def to_json!(:invalid_title), do: "invalid_title"
    def to_json!(:invalid_key), do: "invalid_key"
    def to_json!(:invalid_supervisor_id), do: "invalid_supervisor_id"
    def to_json!(:invalid_leading_office_id), do: "invalid_leading_office_id"
    def to_json!(:invalid_color), do: "invalid_color"
    def to_json!(:invalid_finance_code), do: "invalid_finance_code"
    def to_json!(:invalid_invoiceable), do: "invalid_invoiceable"
    def to_json!(:invalid_is_archived), do: "invalid_is_archived"
    def to_json!(:invalid_task_code), do: "invalid_task_code"
    def to_json!(:supervisor_not_exists), do: "supervisor_not_exists"
    def to_json!(:leading_office_not_exists), do: "leading_office_not_exists"
    def to_json!(:title_already_exists), do: "title_already_exists"
    def to_json!(:key_already_exists), do: "key_already_exists"

  end

  defmodule TimesheetCellAlloc do

    @moduledoc """
    Timesheet
    """
    @enforce_keys [:project_id]
    defstruct [project_id: nil]

    @type t :: %TimesheetCellAlloc{project_id: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      project_id = Igor.Json.parse_field!(json, "project_id", :long)
      %TimesheetCellAlloc{project_id: project_id}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{project_id: project_id} = args
      %{
        "project_id" => Igor.Json.pack_value(project_id, :long)
      }
    end

  end

  defmodule TimesheetCellAllocError do

    @type t ::
      :invalid_project_id #
    | :project_not_exists #

    defguard is_timesheet_cell_alloc_error(value) when value === :invalid_project_id or value === :project_not_exists

    @spec from_string!(String.t()) :: t()
    def from_string!("invalid_project_id"), do: :invalid_project_id
    def from_string!("project_not_exists"), do: :project_not_exists

    @spec to_string!(t()) :: String.t()
    def to_string!(:invalid_project_id), do: "invalid_project_id"
    def to_string!(:project_not_exists), do: "project_not_exists"

    @spec from_json!(String.t()) :: t()
    def from_json!("invalid_project_id"), do: :invalid_project_id
    def from_json!("project_not_exists"), do: :project_not_exists

    @spec to_json!(t()) :: String.t()
    def to_json!(:invalid_project_id), do: "invalid_project_id"
    def to_json!(:project_not_exists), do: "project_not_exists"

  end

  defmodule TimesheetCellAllocMany do

    @enforce_keys [:date_since, :date_till]
    defstruct [project_id: nil, date_since: nil, date_till: nil]

    @type t :: %TimesheetCellAllocMany{project_id: integer | nil, date_since: CommonProtocol.date_time(), date_till: CommonProtocol.date_time()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      project_id = Igor.Json.parse_field!(json, "project_id", :long, nil)
      date_since = Igor.Json.parse_field!(json, "date_since", {:custom, Util.DateTime})
      date_till = Igor.Json.parse_field!(json, "date_till", {:custom, Util.DateTime})
      %TimesheetCellAllocMany{project_id: project_id, date_since: date_since, date_till: date_till}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{project_id: project_id, date_since: date_since, date_till: date_till} = args
      %{}
        |> Igor.Json.pack_field("project_id", project_id, :long)
        |> Igor.Json.pack_field("date_since", date_since, {:custom, Util.DateTime})
        |> Igor.Json.pack_field("date_till", date_till, {:custom, Util.DateTime})
    end

  end

  defmodule TimesheetCellAllocManyError do

    @type t ::
      :invalid_project_id #
    | :invalid_date_since #
    | :invalid_date_till #
    | :project_not_exists #

    defguard is_timesheet_cell_alloc_many_error(value) when value === :invalid_project_id or value === :invalid_date_since or value === :invalid_date_till or value === :project_not_exists

    @spec from_string!(String.t()) :: t()
    def from_string!("invalid_project_id"), do: :invalid_project_id
    def from_string!("invalid_date_since"), do: :invalid_date_since
    def from_string!("invalid_date_till"), do: :invalid_date_till
    def from_string!("project_not_exists"), do: :project_not_exists

    @spec to_string!(t()) :: String.t()
    def to_string!(:invalid_project_id), do: "invalid_project_id"
    def to_string!(:invalid_date_since), do: "invalid_date_since"
    def to_string!(:invalid_date_till), do: "invalid_date_till"
    def to_string!(:project_not_exists), do: "project_not_exists"

    @spec from_json!(String.t()) :: t()
    def from_json!("invalid_project_id"), do: :invalid_project_id
    def from_json!("invalid_date_since"), do: :invalid_date_since
    def from_json!("invalid_date_till"), do: :invalid_date_till
    def from_json!("project_not_exists"), do: :project_not_exists

    @spec to_json!(t()) :: String.t()
    def to_json!(:invalid_project_id), do: "invalid_project_id"
    def to_json!(:invalid_date_since), do: "invalid_date_since"
    def to_json!(:invalid_date_till), do: "invalid_date_till"
    def to_json!(:project_not_exists), do: "project_not_exists"

  end

  defmodule TimesheetCellOff do

    @enforce_keys [:time_off]
    defstruct [time_off: nil]

    @type t :: %TimesheetCellOff{time_off: DbProtocol.TimeOffKind.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      time_off = Igor.Json.parse_field!(json, "time_off", {:custom, DbProtocol.TimeOffKind})
      %TimesheetCellOff{time_off: time_off}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{time_off: time_off} = args
      %{
        "time_off" => DbProtocol.TimeOffKind.to_json!(time_off)
      }
    end

  end

  defmodule TimesheetCellOffError do

    @type t ::
      :invalid_time_off #

    defguard is_timesheet_cell_off_error(value) when value === :invalid_time_off

    @spec from_string!(String.t()) :: t()
    def from_string!("invalid_time_off"), do: :invalid_time_off

    @spec to_string!(t()) :: String.t()
    def to_string!(:invalid_time_off), do: "invalid_time_off"

    @spec from_json!(String.t()) :: t()
    def from_json!("invalid_time_off"), do: :invalid_time_off

    @spec to_json!(t()) :: String.t()
    def to_json!(:invalid_time_off), do: "invalid_time_off"

  end

  defmodule TimesheetSelectorMonth do

    @enforce_keys [:year, :month]
    defstruct [year: nil, month: nil]

    @type t :: %TimesheetSelectorMonth{year: integer, month: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      year = Igor.Json.parse_field!(json, "year", :int)
      month = Igor.Json.parse_field!(json, "month", :int)
      %TimesheetSelectorMonth{year: year, month: month}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{year: year, month: month} = args
      %{
        "year" => Igor.Json.pack_value(year, :int),
        "month" => Igor.Json.pack_value(month, :int)
      }
    end

  end

  defmodule TimesheetSelector do

    @enforce_keys [:ids]
    defstruct [ids: nil]

    @type t :: %TimesheetSelector{ids: [integer]}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      ids = Igor.Json.parse_field!(json, "ids", {:list, :long})
      %TimesheetSelector{ids: ids}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{ids: ids} = args
      %{
        "ids" => Igor.Json.pack_value(ids, {:list, :long})
      }
    end

  end

  defmodule BulkTimesheetAction do

    @enforce_keys [:cells]
    defstruct [cells: nil]

    @type t :: %BulkTimesheetAction{cells: WebProtocol.TimesheetSelector.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      cells = Igor.Json.parse_field!(json, "cells", {:custom, WebProtocol.TimesheetSelector})
      %BulkTimesheetAction{cells: cells}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{cells: cells} = args
      %{
        "cells" => WebProtocol.TimesheetSelector.to_json!(cells)
      }
    end

  end

  defmodule BulkTimesheetAllocate do

    @enforce_keys [:cells, :project_id]
    defstruct [cells: nil, project_id: nil]

    @type t :: %BulkTimesheetAllocate{cells: WebProtocol.TimesheetSelector.t(), project_id: integer}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      cells = Igor.Json.parse_field!(json, "cells", {:custom, WebProtocol.TimesheetSelector})
      project_id = Igor.Json.parse_field!(json, "project_id", :long)
      %BulkTimesheetAllocate{cells: cells, project_id: project_id}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{cells: cells, project_id: project_id} = args
      %{
        "cells" => WebProtocol.TimesheetSelector.to_json!(cells),
        "project_id" => Igor.Json.pack_value(project_id, :long)
      }
    end

  end

  defmodule BulkTimesheetTimeOff do

    @enforce_keys [:cells, :time_off]
    defstruct [cells: nil, time_off: nil]

    @type t :: %BulkTimesheetTimeOff{cells: WebProtocol.TimesheetSelector.t(), time_off: DbProtocol.TimeOffKind.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      cells = Igor.Json.parse_field!(json, "cells", {:custom, WebProtocol.TimesheetSelector})
      time_off = Igor.Json.parse_field!(json, "time_off", {:custom, DbProtocol.TimeOffKind})
      %BulkTimesheetTimeOff{cells: cells, time_off: time_off}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{cells: cells, time_off: time_off} = args
      %{
        "cells" => WebProtocol.TimesheetSelector.to_json!(cells),
        "time_off" => DbProtocol.TimeOffKind.to_json!(time_off)
      }
    end

  end

  defmodule BulkTimesheetProtect do

    @enforce_keys [:cells]
    defstruct [cells: nil, comment: nil]

    @type t :: %BulkTimesheetProtect{cells: WebProtocol.TimesheetSelector.t(), comment: String.t() | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      cells = Igor.Json.parse_field!(json, "cells", {:custom, WebProtocol.TimesheetSelector})
      comment = Igor.Json.parse_field!(json, "comment", :string, nil)
      %BulkTimesheetProtect{cells: cells, comment: comment}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{cells: cells, comment: comment} = args
      %{}
        |> Igor.Json.pack_field("cells", cells, {:custom, WebProtocol.TimesheetSelector})
        |> Igor.Json.pack_field("comment", comment, :string)
    end

  end

  defmodule MonthlyEmployeeTimesheet do

    @enforce_keys [:personnel_id, :personnel_username, :personnel_name, :linked_to_projects, :highlights, :year, :month]
    defstruct [personnel_id: nil, personnel_username: nil, personnel_name: nil, allocated_to_project_id: nil, allocated_to_project_name: nil, linked_to_projects: nil, highlights: nil, year: nil, month: nil, cells: []]

    @type t :: %MonthlyEmployeeTimesheet{personnel_id: integer, personnel_username: String.t(), personnel_name: String.t(), allocated_to_project_id: integer | nil, allocated_to_project_name: String.t() | nil, linked_to_projects: Igor.Json.json(), highlights: Igor.Json.json(), year: integer, month: integer, cells: [DbProtocol.TimesheetCell.t()]}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      personnel_id = Igor.Json.parse_field!(json, "personnel_id", :long)
      personnel_username = Igor.Json.parse_field!(json, "personnel_username", :string)
      personnel_name = Igor.Json.parse_field!(json, "personnel_name", :string)
      allocated_to_project_id = Igor.Json.parse_field!(json, "allocated_to_project_id", :long, nil)
      allocated_to_project_name = Igor.Json.parse_field!(json, "allocated_to_project_name", :string, nil)
      linked_to_projects = Igor.Json.parse_field!(json, "linked_to_projects", :json)
      highlights = Igor.Json.parse_field!(json, "highlights", :json)
      year = Igor.Json.parse_field!(json, "year", :int)
      month = Igor.Json.parse_field!(json, "month", :int)
      cells = Igor.Json.parse_field!(json, "cells", {:list, {:custom, DbProtocol.TimesheetCell}}, [])
      %MonthlyEmployeeTimesheet{
        personnel_id: personnel_id,
        personnel_username: personnel_username,
        personnel_name: personnel_name,
        allocated_to_project_id: allocated_to_project_id,
        allocated_to_project_name: allocated_to_project_name,
        linked_to_projects: linked_to_projects,
        highlights: highlights,
        year: year,
        month: month,
        cells: cells
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        personnel_id: personnel_id,
        personnel_username: personnel_username,
        personnel_name: personnel_name,
        allocated_to_project_id: allocated_to_project_id,
        allocated_to_project_name: allocated_to_project_name,
        linked_to_projects: linked_to_projects,
        highlights: highlights,
        year: year,
        month: month,
        cells: cells
      } = args
      %{}
        |> Igor.Json.pack_field("personnel_id", personnel_id, :long)
        |> Igor.Json.pack_field("personnel_username", personnel_username, :string)
        |> Igor.Json.pack_field("personnel_name", personnel_name, :string)
        |> Igor.Json.pack_field("allocated_to_project_id", allocated_to_project_id, :long)
        |> Igor.Json.pack_field("allocated_to_project_name", allocated_to_project_name, :string)
        |> Igor.Json.pack_field("linked_to_projects", linked_to_projects, :json)
        |> Igor.Json.pack_field("highlights", highlights, :json)
        |> Igor.Json.pack_field("year", year, :int)
        |> Igor.Json.pack_field("month", month, :int)
        |> Igor.Json.pack_field("cells", cells, {:list, {:custom, DbProtocol.TimesheetCell}})
    end

  end

  defmodule CreateRoleRequest do

    @moduledoc """
    Roles
    """
    @enforce_keys [:code, :title]
    defstruct [code: nil, title: nil]

    @type t :: %CreateRoleRequest{code: String.t(), title: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      code = Igor.Json.parse_field!(json, "code", :string)
      title = Igor.Json.parse_field!(json, "title", :string)
      %CreateRoleRequest{code: code, title: title}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{code: code, title: title} = args
      %{
        "code" => Igor.Json.pack_value(code, :string),
        "title" => Igor.Json.pack_value(title, :string)
      }
    end

  end

  defmodule UpdateRoleRequest do

    @type t :: %{optional(:code) => String.t(), optional(:title) => String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      %{}
        |> field_from_json(json, "code", :string, :code)
        |> field_from_json(json, "title", :string, :title)
    end

    defp field_from_json(map, json, json_key, type, map_key) do
      case Map.fetch(json, json_key) do
        {:ok, value} -> Map.put(map, map_key, Igor.Json.parse_value!(value, type))
        :error -> map
      end
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{}
        |> field_to_json(args, :code, :string, "code")
        |> field_to_json(args, :title, :string, "title")
    end

    defp field_to_json(json, map, map_key, type, json_key) do
      case Map.fetch(map, map_key) do
        {:ok, value} -> Map.put(json, json_key, Igor.Json.pack_value(value, type))
        :error -> json
      end
    end

  end

  defmodule RoleError do

    @type t ::
      :invalid_code #
    | :invalid_title #
    | :code_already_exists #
    | :title_already_exists #

    defguard is_role_error(value) when value === :invalid_code or value === :invalid_title or value === :code_already_exists or value === :title_already_exists

    @spec from_string!(String.t()) :: t()
    def from_string!("invalid_code"), do: :invalid_code
    def from_string!("invalid_title"), do: :invalid_title
    def from_string!("code_already_exists"), do: :code_already_exists
    def from_string!("title_already_exists"), do: :title_already_exists

    @spec to_string!(t()) :: String.t()
    def to_string!(:invalid_code), do: "invalid_code"
    def to_string!(:invalid_title), do: "invalid_title"
    def to_string!(:code_already_exists), do: "code_already_exists"
    def to_string!(:title_already_exists), do: "title_already_exists"

    @spec from_json!(String.t()) :: t()
    def from_json!("invalid_code"), do: :invalid_code
    def from_json!("invalid_title"), do: :invalid_title
    def from_json!("code_already_exists"), do: :code_already_exists
    def from_json!("title_already_exists"), do: :title_already_exists

    @spec to_json!(t()) :: String.t()
    def to_json!(:invalid_code), do: "invalid_code"
    def to_json!(:invalid_title), do: "invalid_title"
    def to_json!(:code_already_exists), do: "code_already_exists"
    def to_json!(:title_already_exists), do: "title_already_exists"

  end

  defmodule RoleForOfficeError do

    @type t ::
      :invalid_role #
    | :invalid_office #
    | :member_not_exists #
    | :member_not_added #
    | :member_already_added #

    defguard is_role_for_office_error(value) when value === :invalid_role or value === :invalid_office or value === :member_not_exists or value === :member_not_added or value === :member_already_added

    @spec from_string!(String.t()) :: t()
    def from_string!("invalid_role"), do: :invalid_role
    def from_string!("invalid_office"), do: :invalid_office
    def from_string!("member_not_exists"), do: :member_not_exists
    def from_string!("member_not_added"), do: :member_not_added
    def from_string!("member_already_added"), do: :member_already_added

    @spec to_string!(t()) :: String.t()
    def to_string!(:invalid_role), do: "invalid_role"
    def to_string!(:invalid_office), do: "invalid_office"
    def to_string!(:member_not_exists), do: "member_not_exists"
    def to_string!(:member_not_added), do: "member_not_added"
    def to_string!(:member_already_added), do: "member_already_added"

    @spec from_json!(String.t()) :: t()
    def from_json!("invalid_role"), do: :invalid_role
    def from_json!("invalid_office"), do: :invalid_office
    def from_json!("member_not_exists"), do: :member_not_exists
    def from_json!("member_not_added"), do: :member_not_added
    def from_json!("member_already_added"), do: :member_already_added

    @spec to_json!(t()) :: String.t()
    def to_json!(:invalid_role), do: "invalid_role"
    def to_json!(:invalid_office), do: "invalid_office"
    def to_json!(:member_not_exists), do: "member_not_exists"
    def to_json!(:member_not_added), do: "member_not_added"
    def to_json!(:member_already_added), do: "member_already_added"

  end

  defmodule CreateHighlightRequest do

    @moduledoc """
    Highlights
    """
    @enforce_keys [:code, :title]
    defstruct [code: nil, title: nil]

    @type t :: %CreateHighlightRequest{code: String.t(), title: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      code = Igor.Json.parse_field!(json, "code", :string)
      title = Igor.Json.parse_field!(json, "title", :string)
      %CreateHighlightRequest{code: code, title: title}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{code: code, title: title} = args
      %{
        "code" => Igor.Json.pack_value(code, :string),
        "title" => Igor.Json.pack_value(title, :string)
      }
    end

  end

  defmodule UpdateHighlightRequest do

    @type t :: %{optional(:code) => String.t(), optional(:title) => String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      %{}
        |> field_from_json(json, "code", :string, :code)
        |> field_from_json(json, "title", :string, :title)
    end

    defp field_from_json(map, json, json_key, type, map_key) do
      case Map.fetch(json, json_key) do
        {:ok, value} -> Map.put(map, map_key, Igor.Json.parse_value!(value, type))
        :error -> map
      end
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{}
        |> field_to_json(args, :code, :string, "code")
        |> field_to_json(args, :title, :string, "title")
    end

    defp field_to_json(json, map, map_key, type, json_key) do
      case Map.fetch(map, map_key) do
        {:ok, value} -> Map.put(json, json_key, Igor.Json.pack_value(value, type))
        :error -> json
      end
    end

  end

  defmodule HighlightError do

    @type t ::
      :invalid_code #
    | :invalid_title #
    | :code_already_exists #
    | :title_already_exists #

    defguard is_highlight_error(value) when value === :invalid_code or value === :invalid_title or value === :code_already_exists or value === :title_already_exists

    @spec from_string!(String.t()) :: t()
    def from_string!("invalid_code"), do: :invalid_code
    def from_string!("invalid_title"), do: :invalid_title
    def from_string!("code_already_exists"), do: :code_already_exists
    def from_string!("title_already_exists"), do: :title_already_exists

    @spec to_string!(t()) :: String.t()
    def to_string!(:invalid_code), do: "invalid_code"
    def to_string!(:invalid_title), do: "invalid_title"
    def to_string!(:code_already_exists), do: "code_already_exists"
    def to_string!(:title_already_exists), do: "title_already_exists"

    @spec from_json!(String.t()) :: t()
    def from_json!("invalid_code"), do: :invalid_code
    def from_json!("invalid_title"), do: :invalid_title
    def from_json!("code_already_exists"), do: :code_already_exists
    def from_json!("title_already_exists"), do: :title_already_exists

    @spec to_json!(t()) :: String.t()
    def to_json!(:invalid_code), do: "invalid_code"
    def to_json!(:invalid_title), do: "invalid_title"
    def to_json!(:code_already_exists), do: "code_already_exists"
    def to_json!(:title_already_exists), do: "title_already_exists"

  end

  defmodule CreateTeamRequest do

    @moduledoc """
    Teams
    """
    @enforce_keys [:title]
    defstruct [title: nil]

    @type t :: %CreateTeamRequest{title: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      title = Igor.Json.parse_field!(json, "title", :string)
      %CreateTeamRequest{title: title}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{title: title} = args
      %{
        "title" => Igor.Json.pack_value(title, :string)
      }
    end

  end

  defmodule UpdateTeamRequest do

    @type t :: %{optional(:title) => String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      %{}
        |> field_from_json(json, "title", :string, :title)
    end

    defp field_from_json(map, json, json_key, type, map_key) do
      case Map.fetch(json, json_key) do
        {:ok, value} -> Map.put(map, map_key, Igor.Json.parse_value!(value, type))
        :error -> map
      end
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{}
        |> field_to_json(args, :title, :string, "title")
    end

    defp field_to_json(json, map, map_key, type, json_key) do
      case Map.fetch(map, map_key) do
        {:ok, value} -> Map.put(json, json_key, Igor.Json.pack_value(value, type))
        :error -> json
      end
    end

  end

  defmodule TeamError do

    @type t ::
      :invalid_title #
    | :invalid_created_by #
    | :title_already_exists #
    | :created_by_not_exists #

    defguard is_team_error(value) when value === :invalid_title or value === :invalid_created_by or value === :title_already_exists or value === :created_by_not_exists

    @spec from_string!(String.t()) :: t()
    def from_string!("invalid_title"), do: :invalid_title
    def from_string!("invalid_created_by"), do: :invalid_created_by
    def from_string!("title_already_exists"), do: :title_already_exists
    def from_string!("created_by_not_exists"), do: :created_by_not_exists

    @spec to_string!(t()) :: String.t()
    def to_string!(:invalid_title), do: "invalid_title"
    def to_string!(:invalid_created_by), do: "invalid_created_by"
    def to_string!(:title_already_exists), do: "title_already_exists"
    def to_string!(:created_by_not_exists), do: "created_by_not_exists"

    @spec from_json!(String.t()) :: t()
    def from_json!("invalid_title"), do: :invalid_title
    def from_json!("invalid_created_by"), do: :invalid_created_by
    def from_json!("title_already_exists"), do: :title_already_exists
    def from_json!("created_by_not_exists"), do: :created_by_not_exists

    @spec to_json!(t()) :: String.t()
    def to_json!(:invalid_title), do: "invalid_title"
    def to_json!(:invalid_created_by), do: "invalid_created_by"
    def to_json!(:title_already_exists), do: "title_already_exists"
    def to_json!(:created_by_not_exists), do: "created_by_not_exists"

  end

  defmodule TeamMemberError do

    @type t ::
      :member_not_exists #
    | :member_not_added #
    | :member_already_added #

    defguard is_team_member_error(value) when value === :member_not_exists or value === :member_not_added or value === :member_already_added

    @spec from_string!(String.t()) :: t()
    def from_string!("member_not_exists"), do: :member_not_exists
    def from_string!("member_not_added"), do: :member_not_added
    def from_string!("member_already_added"), do: :member_already_added

    @spec to_string!(t()) :: String.t()
    def to_string!(:member_not_exists), do: "member_not_exists"
    def to_string!(:member_not_added), do: "member_not_added"
    def to_string!(:member_already_added), do: "member_already_added"

    @spec from_json!(String.t()) :: t()
    def from_json!("member_not_exists"), do: :member_not_exists
    def from_json!("member_not_added"), do: :member_not_added
    def from_json!("member_already_added"), do: :member_already_added

    @spec to_json!(t()) :: String.t()
    def to_json!(:member_not_exists), do: "member_not_exists"
    def to_json!(:member_not_added), do: "member_not_added"
    def to_json!(:member_already_added), do: "member_already_added"

  end

  defmodule TeamManagerError do

    @type t ::
      :manager_not_exists #
    | :manager_is_owner #

    defguard is_team_manager_error(value) when value === :manager_not_exists or value === :manager_is_owner

    @spec from_string!(String.t()) :: t()
    def from_string!("manager_not_exists"), do: :manager_not_exists
    def from_string!("manager_is_owner"), do: :manager_is_owner

    @spec to_string!(t()) :: String.t()
    def to_string!(:manager_not_exists), do: "manager_not_exists"
    def to_string!(:manager_is_owner), do: "manager_is_owner"

    @spec from_json!(String.t()) :: t()
    def from_json!("manager_not_exists"), do: :manager_not_exists
    def from_json!("manager_is_owner"), do: :manager_is_owner

    @spec to_json!(t()) :: String.t()
    def to_json!(:manager_not_exists), do: "manager_not_exists"
    def to_json!(:manager_is_owner), do: "manager_is_owner"

  end

  defmodule SyncBambooTaskRequest do

    defstruct [office_id: nil, project_id: nil, team_id: nil]

    @type t :: %SyncBambooTaskRequest{office_id: integer | nil, project_id: integer | nil, team_id: integer | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      office_id = Igor.Json.parse_field!(json, "office_id", :long, nil)
      project_id = Igor.Json.parse_field!(json, "project_id", :long, nil)
      team_id = Igor.Json.parse_field!(json, "team_id", :long, nil)
      %SyncBambooTaskRequest{office_id: office_id, project_id: project_id, team_id: team_id}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{office_id: office_id, project_id: project_id, team_id: team_id} = args
      %{}
        |> Igor.Json.pack_field("office_id", office_id, :long)
        |> Igor.Json.pack_field("project_id", project_id, :long)
        |> Igor.Json.pack_field("team_id", team_id, :long)
    end

  end

  defmodule TaskError do

    @type t ::
      :invalid_office_id #
    | :invalid_project_id #
    | :invalid_team_id #

    defguard is_task_error(value) when value === :invalid_office_id or value === :invalid_project_id or value === :invalid_team_id

    @spec from_string!(String.t()) :: t()
    def from_string!("invalid_office_id"), do: :invalid_office_id
    def from_string!("invalid_project_id"), do: :invalid_project_id
    def from_string!("invalid_team_id"), do: :invalid_team_id

    @spec to_string!(t()) :: String.t()
    def to_string!(:invalid_office_id), do: "invalid_office_id"
    def to_string!(:invalid_project_id), do: "invalid_project_id"
    def to_string!(:invalid_team_id), do: "invalid_team_id"

    @spec from_json!(String.t()) :: t()
    def from_json!("invalid_office_id"), do: :invalid_office_id
    def from_json!("invalid_project_id"), do: :invalid_project_id
    def from_json!("invalid_team_id"), do: :invalid_team_id

    @spec to_json!(t()) :: String.t()
    def to_json!(:invalid_office_id), do: "invalid_office_id"
    def to_json!(:invalid_project_id), do: "invalid_project_id"
    def to_json!(:invalid_team_id), do: "invalid_team_id"

  end

  defmodule HistoryEntryOrderBy do

    @type t ::
      :id #
    | :actor #
    | :actor_id #
    | :actor_name #
    | :actor_username #
    | :entity #
    | :entity_id #
    | :entity_param #
    | :operation #
    | :is_bulk #
    | :result #
    | :created_at #

    defguard is_history_entry_order_by(value) when value === :id or value === :actor or value === :actor_id or value === :actor_name or value === :actor_username or value === :entity or value === :entity_id or value === :entity_param or value === :operation or value === :is_bulk or value === :result or value === :created_at

    @spec from_string!(String.t()) :: t()
    def from_string!("id"), do: :id
    def from_string!("actor"), do: :actor
    def from_string!("actor_id"), do: :actor_id
    def from_string!("actor_name"), do: :actor_name
    def from_string!("actor_username"), do: :actor_username
    def from_string!("entity"), do: :entity
    def from_string!("entity_id"), do: :entity_id
    def from_string!("entity_param"), do: :entity_param
    def from_string!("operation"), do: :operation
    def from_string!("is_bulk"), do: :is_bulk
    def from_string!("result"), do: :result
    def from_string!("created_at"), do: :created_at

    @spec to_string!(t()) :: String.t()
    def to_string!(:id), do: "id"
    def to_string!(:actor), do: "actor"
    def to_string!(:actor_id), do: "actor_id"
    def to_string!(:actor_name), do: "actor_name"
    def to_string!(:actor_username), do: "actor_username"
    def to_string!(:entity), do: "entity"
    def to_string!(:entity_id), do: "entity_id"
    def to_string!(:entity_param), do: "entity_param"
    def to_string!(:operation), do: "operation"
    def to_string!(:is_bulk), do: "is_bulk"
    def to_string!(:result), do: "result"
    def to_string!(:created_at), do: "created_at"

    @spec from_json!(String.t()) :: t()
    def from_json!("id"), do: :id
    def from_json!("actor"), do: :actor
    def from_json!("actor_id"), do: :actor_id
    def from_json!("actor_name"), do: :actor_name
    def from_json!("actor_username"), do: :actor_username
    def from_json!("entity"), do: :entity
    def from_json!("entity_id"), do: :entity_id
    def from_json!("entity_param"), do: :entity_param
    def from_json!("operation"), do: :operation
    def from_json!("is_bulk"), do: :is_bulk
    def from_json!("result"), do: :result
    def from_json!("created_at"), do: :created_at

    @spec to_json!(t()) :: String.t()
    def to_json!(:id), do: "id"
    def to_json!(:actor), do: "actor"
    def to_json!(:actor_id), do: "actor_id"
    def to_json!(:actor_name), do: "actor_name"
    def to_json!(:actor_username), do: "actor_username"
    def to_json!(:entity), do: "entity"
    def to_json!(:entity_id), do: "entity_id"
    def to_json!(:entity_param), do: "entity_param"
    def to_json!(:operation), do: "operation"
    def to_json!(:is_bulk), do: "is_bulk"
    def to_json!(:result), do: "result"
    def to_json!(:created_at), do: "created_at"

  end

  defmodule CreateVismaReportRequest do

    @enforce_keys [:office_id, :year, :month, :comment]
    defstruct [office_id: nil, year: nil, month: nil, comment: nil, omit_ids: [], omit_uids: [], pretty: false]

    @type t :: %CreateVismaReportRequest{office_id: integer, year: integer, month: integer, comment: String.t(), omit_ids: [integer] | nil, omit_uids: [String.t()] | nil, pretty: boolean | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      office_id = Igor.Json.parse_field!(json, "office_id", :long)
      year = Igor.Json.parse_field!(json, "year", :int)
      month = Igor.Json.parse_field!(json, "month", :int)
      comment = Igor.Json.parse_field!(json, "comment", :string)
      omit_ids = Igor.Json.parse_field!(json, "omit_ids", {:list, :long}, [])
      omit_uids = Igor.Json.parse_field!(json, "omit_uids", {:list, :string}, [])
      pretty = Igor.Json.parse_field!(json, "pretty", :boolean, false)
      %CreateVismaReportRequest{
        office_id: office_id,
        year: year,
        month: month,
        comment: comment,
        omit_ids: omit_ids,
        omit_uids: omit_uids,
        pretty: pretty
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        office_id: office_id,
        year: year,
        month: month,
        comment: comment,
        omit_ids: omit_ids,
        omit_uids: omit_uids,
        pretty: pretty
      } = args
      %{}
        |> Igor.Json.pack_field("office_id", office_id, :long)
        |> Igor.Json.pack_field("year", year, :int)
        |> Igor.Json.pack_field("month", month, :int)
        |> Igor.Json.pack_field("comment", comment, :string)
        |> Igor.Json.pack_field("omit_ids", omit_ids, {:list, :long})
        |> Igor.Json.pack_field("omit_uids", omit_uids, {:list, :string})
        |> Igor.Json.pack_field("pretty", pretty, :boolean)
    end

  end

  defmodule UpdateVismaReportRequest do

    @type t :: %{optional(:comment) => String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      %{}
        |> field_from_json(json, "comment", :string, :comment)
    end

    defp field_from_json(map, json, json_key, type, map_key) do
      case Map.fetch(json, json_key) do
        {:ok, value} -> Map.put(map, map_key, Igor.Json.parse_value!(value, type))
        :error -> map
      end
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{}
        |> field_to_json(args, :comment, :string, "comment")
    end

    defp field_to_json(json, map, map_key, type, json_key) do
      case Map.fetch(map, map_key) do
        {:ok, value} -> Map.put(json, json_key, Igor.Json.pack_value(value, type))
        :error -> json
      end
    end

  end

  defmodule VismaReportOrderBy do

    @type t ::
      :id #
    | :created_by #
    | :created_by_username #
    | :created_by_name #
    | :created_at #
    | :updated_at #

    defguard is_visma_report_order_by(value) when value === :id or value === :created_by or value === :created_by_username or value === :created_by_name or value === :created_at or value === :updated_at

    @spec from_string!(String.t()) :: t()
    def from_string!("id"), do: :id
    def from_string!("created_by"), do: :created_by
    def from_string!("created_by_username"), do: :created_by_username
    def from_string!("created_by_name"), do: :created_by_name
    def from_string!("created_at"), do: :created_at
    def from_string!("updated_at"), do: :updated_at

    @spec to_string!(t()) :: String.t()
    def to_string!(:id), do: "id"
    def to_string!(:created_by), do: "created_by"
    def to_string!(:created_by_username), do: "created_by_username"
    def to_string!(:created_by_name), do: "created_by_name"
    def to_string!(:created_at), do: "created_at"
    def to_string!(:updated_at), do: "updated_at"

    @spec from_json!(String.t()) :: t()
    def from_json!("id"), do: :id
    def from_json!("created_by"), do: :created_by
    def from_json!("created_by_username"), do: :created_by_username
    def from_json!("created_by_name"), do: :created_by_name
    def from_json!("created_at"), do: :created_at
    def from_json!("updated_at"), do: :updated_at

    @spec to_json!(t()) :: String.t()
    def to_json!(:id), do: "id"
    def to_json!(:created_by), do: "created_by"
    def to_json!(:created_by_username), do: "created_by_username"
    def to_json!(:created_by_name), do: "created_by_name"
    def to_json!(:created_at), do: "created_at"
    def to_json!(:updated_at), do: "updated_at"

  end

  defmodule VismaReportError do

    @type t ::
      :invalid_office_id #
    | :invalid_year #
    | :invalid_month #
    | :invalid_comment #

    defguard is_visma_report_error(value) when value === :invalid_office_id or value === :invalid_year or value === :invalid_month or value === :invalid_comment

    @spec from_string!(String.t()) :: t()
    def from_string!("invalid_office_id"), do: :invalid_office_id
    def from_string!("invalid_year"), do: :invalid_year
    def from_string!("invalid_month"), do: :invalid_month
    def from_string!("invalid_comment"), do: :invalid_comment

    @spec to_string!(t()) :: String.t()
    def to_string!(:invalid_office_id), do: "invalid_office_id"
    def to_string!(:invalid_year), do: "invalid_year"
    def to_string!(:invalid_month), do: "invalid_month"
    def to_string!(:invalid_comment), do: "invalid_comment"

    @spec from_json!(String.t()) :: t()
    def from_json!("invalid_office_id"), do: :invalid_office_id
    def from_json!("invalid_year"), do: :invalid_year
    def from_json!("invalid_month"), do: :invalid_month
    def from_json!("invalid_comment"), do: :invalid_comment

    @spec to_json!(t()) :: String.t()
    def to_json!(:invalid_office_id), do: "invalid_office_id"
    def to_json!(:invalid_year), do: "invalid_year"
    def to_json!(:invalid_month), do: "invalid_month"
    def to_json!(:invalid_comment), do: "invalid_comment"

  end

  defmodule VismaReportDeliveryError do

    @type t ::
      :invalid_auth #
    | :invalid_visma_country #
    | :invalid_visma_company_id #

    defguard is_visma_report_delivery_error(value) when value === :invalid_auth or value === :invalid_visma_country or value === :invalid_visma_company_id

    @spec from_string!(String.t()) :: t()
    def from_string!("invalid_auth"), do: :invalid_auth
    def from_string!("invalid_visma_country"), do: :invalid_visma_country
    def from_string!("invalid_visma_company_id"), do: :invalid_visma_company_id

    @spec to_string!(t()) :: String.t()
    def to_string!(:invalid_auth), do: "invalid_auth"
    def to_string!(:invalid_visma_country), do: "invalid_visma_country"
    def to_string!(:invalid_visma_company_id), do: "invalid_visma_company_id"

    @spec from_json!(String.t()) :: t()
    def from_json!("invalid_auth"), do: :invalid_auth
    def from_json!("invalid_visma_country"), do: :invalid_visma_country
    def from_json!("invalid_visma_company_id"), do: :invalid_visma_company_id

    @spec to_json!(t()) :: String.t()
    def to_json!(:invalid_auth), do: "invalid_auth"
    def to_json!(:invalid_visma_country), do: "invalid_visma_country"
    def to_json!(:invalid_visma_company_id), do: "invalid_visma_company_id"

  end

  defmodule OmittedEmployees do

    defstruct [omit_ids: [], omit_uids: []]

    @type t :: %OmittedEmployees{omit_ids: [integer] | nil, omit_uids: [String.t()] | nil}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      omit_ids = Igor.Json.parse_field!(json, "omit_ids", {:list, :long}, [])
      omit_uids = Igor.Json.parse_field!(json, "omit_uids", {:list, :string}, [])
      %OmittedEmployees{omit_ids: omit_ids, omit_uids: omit_uids}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{omit_ids: omit_ids, omit_uids: omit_uids} = args
      %{}
        |> Igor.Json.pack_field("omit_ids", omit_ids, {:list, :long})
        |> Igor.Json.pack_field("omit_uids", omit_uids, {:list, :string})
    end

  end

end
