# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule WebProtocol.HermesEmployeeService.Impl do

  require WebProtocol.PersonnelAccountOrderBy
  require DataProtocol.OrderDirection
  require Util.Date

  @behaviour WebProtocol.HermesEmployeeService

  # ----------------------------------------------------------------------------

  defmacro __using__(which) when is_atom(which), do: apply(__MODULE__, which, [])

  def router() do
    quote do
      match "/api/employees", to: WebProtocol.HermesEmployeeService.GetEmployees
      match "/api/employees/office/:office_id", to: WebProtocol.HermesEmployeeService.GetEmployeesByOffice
      match "/api/employees/project/:project_id", to: WebProtocol.HermesEmployeeService.GetEmployeesByProject
      match "/api/employees/username/:username", to: WebProtocol.HermesEmployeeService.GetEmployeeByUsername
      match "/api/employees/:id", to: WebProtocol.HermesEmployeeService.GetEmployee
      match "/api/employees/:id/alloc", to: WebProtocol.HermesEmployeeService.EmployeeAlloc
      match "/api/employees/:personnel_id/project/:project_id", to: WebProtocol.HermesEmployeeService.EmployeeProject
      match "/api/employees/:personnel_id/project/:project_id/highlight/:highlight_id", to: WebProtocol.HermesEmployeeService.EmployeeHighlight
    end
  end

  # ----------------------------------------------------------------------------

  @doc """
  Get employee by ID
  """
  @spec get_employee(
    id :: integer,
    session :: any()
  ) :: DbProtocol.PersonnelAccount.t()
  @impl true
  def get_employee(
    id,
    session
  ) when
    is_integer(id)
  do
    unless Hermes.can_login?(session), do: raise DataProtocol.ForbiddenError
    item = Hermes.get_employee!(id)
    # log_user_action(session, :read, item)
    item
  end

  # ----------------------------------------------------------------------------

  @doc """
  Get employee by username
  """
  @spec get_employee_by_username(
    username :: String.t(),
    session :: any()
  ) :: DbProtocol.PersonnelAccount.t()
  @impl true
  def get_employee_by_username(
    username,
    session
  ) when
    is_binary(username)
  do
    unless Hermes.can_login?(session), do: raise DataProtocol.ForbiddenError
    item = Hermes.get_employee_by_username!(username)
    # log_user_action(session, :read, item)
    item
  end

  # ----------------------------------------------------------------------------

  @doc """
  Get employees
  """
  @spec get_employees(
    needle :: String.t() | nil,
    order_by :: WebProtocol.PersonnelAccountOrderBy.t(),
    order_dir :: DataProtocol.OrderDirection.t(),
    offset :: integer,
    limit :: integer,
    session :: any()
  ) :: DataProtocol.CollectionSlice.t(DbProtocol.PersonnelAccount.t())
  @impl true
  def get_employees(
    needle,
    order_by,
    order_dir,
    offset,
    limit,
    session
  ) when
    (is_binary(needle) or needle === nil) and
    WebProtocol.PersonnelAccountOrderBy.is_personnel_account_order_by(order_by) and
    DataProtocol.OrderDirection.is_order_direction(order_dir) and
    is_integer(offset) and
    is_integer(limit)
  do
    unless Hermes.can_login?(session), do: raise DataProtocol.ForbiddenError
    items = Hermes.get_employees(needle, order_by, order_dir, offset, limit)
    total = Hermes.count_employees(needle, order_by, order_dir, offset, limit)
    %DataProtocol.CollectionSlice{items: items, total: total}
  end

  # ----------------------------------------------------------------------------

  @doc """
  Get all employee for supplied office
  """
  @spec get_employees_by_office(
    office_id :: integer,
    session :: any()
  ) :: DataProtocol.Collection.t(DbProtocol.PersonnelAccount.t())
  @impl true
  def get_employees_by_office(
    office_id,
    session
  ) when
    is_integer(office_id)
  do
    unless Hermes.can_login?(session), do: raise DataProtocol.ForbiddenError
    items = Hermes.get_employees_by_office(office_id)
    %DataProtocol.Collection{items: items}
  end

  # ----------------------------------------------------------------------------

  @doc """
  Get all employee assigned to supplied project
  """
  @spec get_employees_by_project(
    project_id :: integer,
    since :: CommonProtocol.date() | nil,
    till :: CommonProtocol.date() | nil,
    session :: any()
  ) :: DataProtocol.Collection.t(DbProtocol.PersonnelAccount.t())
  @impl true
  def get_employees_by_project(
    project_id,
    since,
    till,
    session
  ) when
    is_integer(project_id) and
    (Util.Date.is_date(since) or since === nil) and
    (Util.Date.is_date(till) or till === nil)
  do
    unless Hermes.can_login?(session), do: raise DataProtocol.ForbiddenError
    items = Hermes.get_employees_by_project(project_id, since, till)
    %DataProtocol.Collection{items: items}
  end

  # ----------------------------------------------------------------------------

  @doc """
  Allocate employee to project
  """
  @spec allocate_employee(
    request_content :: WebProtocol.EmployeeAlloc.t(),
    id :: integer,
    session :: any()
  ) :: DbProtocol.PersonnelAccount.t()
  @impl true
  def allocate_employee(
    request_content,
    id,
    session
  ) when
    is_struct(request_content, WebProtocol.EmployeeAlloc) and
    is_integer(id)
  do
    unless Hermes.can_allocate_employee?(session), do: raise DataProtocol.ForbiddenError
    raise "not_yet_implemented"
  end

  # ----------------------------------------------------------------------------

  @doc """
  Deallocate employee from project
  """
  @spec deallocate_employee(
    id :: integer,
    session :: any()
  ) :: DbProtocol.PersonnelAccount.t()
  @impl true
  def deallocate_employee(
    id,
    session
  ) when
    is_integer(id)
  do
    unless Hermes.can_deallocate_employee?(session), do: raise DataProtocol.ForbiddenError
    raise "not_yet_implemented"
  end

  # ----------------------------------------------------------------------------

  @doc """
  Add an employee highlight to particular project
  """
  @spec add_employee_highlight(
    request_content :: CommonProtocol.Empty.t(),
    personnel_id :: integer,
    project_id :: integer,
    highlight_id :: integer,
    session :: any()
  ) :: DbProtocol.PersonnelAccount.t()
  @impl true
  def add_employee_highlight(
    request_content,
    personnel_id,
    project_id,
    highlight_id,
    session
  ) when
    is_struct(request_content, CommonProtocol.Empty) and
    is_integer(personnel_id) and
    is_integer(project_id) and
    is_integer(highlight_id)
  do
    unless Hermes.can_assign_highlights?(session), do: raise DataProtocol.ForbiddenError
    raise "not_yet_implemented"
  end

  # ----------------------------------------------------------------------------

  @doc """
  Remove an employee highlight from particular project
  """
  @spec remove_employee_highlight(
    personnel_id :: integer,
    project_id :: integer,
    highlight_id :: integer,
    session :: any()
  ) :: DbProtocol.PersonnelAccount.t()
  @impl true
  def remove_employee_highlight(
    personnel_id,
    project_id,
    highlight_id,
    session
  ) when
    is_integer(personnel_id) and
    is_integer(project_id) and
    is_integer(highlight_id)
  do
    unless Hermes.can_assign_highlights?(session), do: raise DataProtocol.ForbiddenError
    raise "not_yet_implemented"
  end

  # ----------------------------------------------------------------------------

  @doc """
  Add an employee link to particular project
  """
  @spec link_employee_to_project(
    request_content :: CommonProtocol.Empty.t(),
    personnel_id :: integer,
    project_id :: integer,
    session :: any()
  ) :: DbProtocol.PersonnelAccount.t()
  @impl true
  def link_employee_to_project(
    request_content,
    personnel_id,
    project_id,
    session
  ) when
    is_struct(request_content, CommonProtocol.Empty) and
    is_integer(personnel_id) and
    is_integer(project_id)
  do
    unless Hermes.can_link_project?(session), do: raise DataProtocol.ForbiddenError
    raise "not_yet_implemented"
  end

  # ----------------------------------------------------------------------------

  @doc """
  Remove an employee link to particular project
  """
  @spec unlink_employee_from_project(
    personnel_id :: integer,
    project_id :: integer,
    session :: any()
  ) :: DbProtocol.PersonnelAccount.t()
  @impl true
  def unlink_employee_from_project(
    personnel_id,
    project_id,
    session
  ) when
    is_integer(personnel_id) and
    is_integer(project_id)
  do
    unless Hermes.can_link_project?(session), do: raise DataProtocol.ForbiddenError
    raise "not_yet_implemented"
  end

end
